#!/usr/bin/zsh

usage () {<< \
-------------------------------------------------------------------------------

atypical

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

atypical manifest-filename
atypical /full/absolute/path/to/manifest-filename
atypical http://url/of/file/to/curl

Options:

-d, --debug     Debug level 1: show extra command output
-dd, --ddebug   Debug level 2: add verbose script execution option
-ddd, --dddebug Debug level 3: add xtrace script execution option

Examples:

atypical gnome_system
atypical xmonad_laptop
atypical /root/atypical/manifests/quick_modified_gnome_system
atypical http://myserver.com/my_laptop_manifest

(see manifest subdirectory for manifest file content details)

-------------------------------------------------------------------------------
exit ${1:-0}; }

:<< \
-------------------------------------------------------------------------------
Frontmatter
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions

SCRIPTNAME="${${SCRIPTPATH:=$(readlink -f $0)}:t}" SCRIPTROOT="${SCRIPTPATH:h}"

[[ ! -d "${COMMON::=${(q)SCRIPTROOT}/common}" ]] \
    && { print "\nERROR: no common directory! Exiting.\n"; exit 1; } \
    || for _common in ${COMMON:-}/*; do source ${_common}; done

:''<< \
-------------------------------------------------------------------------------
Setting up installer, beginning installation...
-------------------------------------------------------------------------------
# initial declarations
typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

# default values for new system mount point, temp files
MOUNTROOT="/mnt"

# helper function to set up autoload functions by scanning directories
autoInit () { for _newpath; do [[ -d "$_newpath" ]] && \
    fpath=("$_newpath" "${fpath[@]}") _newfuncs=(${_newpath}/**/*(.))
    for _func in "${(@)_newfuncs}"; do autoload ${_func:t}; done; done; }

# our "data" directories (non executable file content)
DATAPATHS[MANIFESTS]="${SCRIPTROOT}/manifests"
DATAPATHS[STORAGE]="${SCRIPTROOT}/storage"

# our initial built-in function directories
AUTOPATHS[INSTALLERS]="${SCRIPTROOT}/installers"
AUTOPATHS[FUNCTIONS]="${SCRIPTROOT}/functions"
AUTOPATHS[USER]="${SCRIPTROOT}/user"

# all files in directories (and recursively scanned subdirectories) listed in
# AUTOPATHS will be set as autoload functions
autoInit "${(@)AUTOPATHS}"

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical manifest file
-------------------------------------------------------------------------------
# If the manifest file hasn't been specified as arg 1 on the command line, fail
if [[ -z ${MANIFEST[FILE]:=${1:-}} ]]; then
    teeLog "MANIFEST FILE NOT SPECIFIED" && usage 1
fi

# Make sure we can load the file. sourceFile will source local manifests
# in the default manifests subdirectory of the atypical directory, or will
# load any absolute path provided. Additionally, it will download a remote
# manifest from a given URL.
if sourceFile "${MANIFEST[FILE]}" "${SCRIPTROOT}/manifests"; then
    teeLog "Loaded manifest successfully..."
else
    teeLog "Failure loading manifest..."
    return 1
fi

# If the manifest contains a SCRIPT[CUSTOM]="http://repo.url/goes/here" style
# declaration, that url is used as a git repository "root". This is then
# cloned locally.
if [[ "${SCRIPT[CUSTOM_ROOT]:-}" =~ "(https?|git):.*" ]]; then
    teeLog "Cloning custom script repository..."
    (git clone --progress "${SCRIPT[CUSTOM_ROOT]}" "$TMPDIR/custom") ioLogNull
    if (( $? == 0 )); then
        SCRIPT[CUSTOM_ROOT]="$TMPDIR/custom"
        teeLog "Successfully cloned custom script respository"
    else
        errLog "FAILED to clone custom script respository"
    fi
fi

# If a custom root has been set in the manifest and successfully cloned, its
# subdirectories are scanned and all files added as autoload functions that
# take precedence over built-in autoloaded functions. thus any atypical
# function or installer can (and will) be overridden by a user file of the
# same name.
if [[ "${${SCRIPT[CUSTOM_ROOT]:-}:0:1}" == "/" ]]; then
    DATAPATHS[CUSTOM_MANIFESTS]="${SCRIPT[CUSTOM_ROOT]}/manifests"
    DATAPATHS[CUSTOM_STORAGE]="${SCRIPT[CUSTOM_ROOT]}/storage"
    AUTOPATHS[CUSTOM_FUNCTIONS]="${SCRIPT[CUSTOM_ROOT]}/scripts"
    AUTOPATHS[CUSTOM_INSTALLERS_PATH]="${SCRIPT[CUSTOM_ROOT]}/installers"
    AUTOPATHS[CUSTOM_USER_PATH]="${SCRIPT[CUSTOM_ROOT]}/scripts"
    autoInit "${(@v)AUTOPATHS[(I)CUSTOM*]}" "${SCRIPT[CUSTOM_ROOT]}"
    teeLog "Successfully set custom script source as listed in manifest."
elif [[ -n "${SCRIPT[CUSTOM_ROOT]:-}" ]]; then
    errLog "Failed to source/set new script source as listed in manifest."
fi

:""<< \
-------------------------------------------------------------------------------
Preparing storage
-------------------------------------------------------------------------------
# expects STORAGE[TABLE] as scalar value, either filename or actual table data
# check that we have something in the STORAGE[TABLE] value and if we do then
# convert to array for easy multiline check
if [[ -n "${STORAGE[TABLE]:-}" ]]; then
    STORAGE_TABLE_DATA=(${(f)STORAGE[TABLE]:-})
else
    failWith "No storage table data / filename present in manifest."
fi

# single line value, assume is filename for storage table; check & read
if [[ -z "${STORAGE_TABLE_DATA[2]:-}" ]]; then

    # set up file path for custom storage
    STORAGE_FILE="${DATAPATHS[CUSTOM_STORAGE]:-}/${STORAGE_TABLE_DATA}"

    # if missing, then fallback to built in
    [[ -f "${STORAGE_FILE}" ]] \
    || STORAGE_FILE="${DATAPATHS[STORAGE]}/${STORAGE_TABLE_DATA}"

    # if still missing, we have a problem with a missing file or bad filename
    [[ -f "${STORAGE_FILE}" ]] \
    || failWith "Storage table file not found at $STORAGE_FILE"

    # write file contents to value, stripping comment lines
    egrep -v "^#|^$" "${STORAGE_FILE}" > $TMPDIR/STORAGE_TABLE \
    || failWith "Failed to read storage file $STORAGE_FILE"

    # if we successfully processed, read it into the correct scalar variable
    STORAGE[TABLE]="$(cat $TMPDIR/STORAGE_TABLE)"

    # cleanup
    rm $TMPDIR/STORAGE_TABLE &>/dev/null

fi

# call atypical's init-storage with whatever the current value is
# (init-storage takes either a file path or table data, but we've normalized
# to table data here)
init-storage "${STORAGE[TABLE]}"
print "in script"
exit

:""<< \
-------------------------------------------------------------------------------
INSTALL BASE SYSTEM
-------------------------------------------------------------------------------

# including base-devel by default
pacstrap $MOUNT_ROOT base base-devel

# generate fstab
genfstab -L $MOUNT_ROOT > $MOUNT_ROOT/etc/fstab

:""<< \
-------------------------------------------------------------------------------
INSTALL BOOT LOADER??? NOT HERE?
-------------------------------------------------------------------------------
refind-install --root $MOUNT_ROOT
mv $MOUNT_ROOT/boot/EFI/refind $MOUNT_ROOT/boot/EFI/BOOT
mv $MOUNT_ROOT/boot/EFI/BOOT/refind_x86.efi $MOUNT_ROOT/boot/EFI/BOOT/bootx86.efi

:""<< \
-------------------------------------------------------------------------------
CREATE CHROOT SCRIPT; CHROOT, COMPLETION, CLEANUP
-------------------------------------------------------------------------------
# extract everything after this section with necessary variables prefixed

# initialize new script
CHROOT_SCRIPTNAME="${SCRIPTNAME}-chroot"
CHROOT_SCRIPTPATH="$MOUNT_ROOT/$CHROOT_SCRIPTNAME"
echo "#!/usr/bin/zsh" >> "$CHROOT_SCRIPTPATH"

# dump required variables and arrays into new script
function {
for _param
do
    typeset -p $_param >> "$CHROOT_SCRIPTPATH"
done
} INSTALL CONFIG MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS STORAGE_RECORDS

# dump functions into script
cat ${SCRIPTROOT}/scripts/functions >> "$CHROOT_SCRIPTPATH"

# dump remainder of file into chroot script
sed -n "/>\{10\}/,$ p" "$SCRIPTPATH" >> "$CHROOT_SCRIPTPATH"
chmod +x "$CHROOT_SCRIPTPATH"

#DEBUG
print "CHECK CHROOT SCRIPT"
exit

# chroot
arch-chroot $MOUNT_ROOT "$CHROOT_SCRIPT_NAME"

# post chroot cleanup
rm $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
umount -R $MOUNT_ROOT/boot; umount -R $MOUNT_ROOT; cryptsetup close crypt
echo "check mkinitcpio.conf, efi boot params, etc. and then reboot"; exit
#reboot

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> CHROOT TRIM LINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

:""<< \
-------------------------------------------------------------------------------
INSTALL OTHER BASIC SYSTEM-RELATED PACKAGES
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
SYSTEM CONFIG - LOCALE, TIME, HOSTNAME
-------------------------------------------------------------------------------
export LANG=${CONFIG[LOCALE-CONF]}
print "${CONFIG[LOCALE-GEN]}" >> /etc/locale.gen; locale-gen
print "${CONFIG[LOCALE-CONF]}" > /etc/locale.conf
print "FONT=${CONFIG[CONSOLEFONT]}" >> /etc/vconsole.conf
ln -s /usr/share/zoneinfo/${CONFIG[TIMEZONE]} /etc/localtime
hwclock --systohc --utc
print "${CONFIG[HOSTNAME]}" > /etc/hostname

:""<< \
-------------------------------------------------------------------------------
CLI
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
INSTALL ${PACKAGES[VIDEO]:-}
INSTALL ${PACKAGES[GUI]:-}
enableServices ${SERVICES[GUI]:-}

:""<< \
-------------------------------------------------------------------------------
INITRAMFS
-------------------------------------------------------------------------------
# configure initramfs
FILE=/etc/mkinitcpio.conf

KEY=MODULES; VALUE="\"${CONFIG[INIT_MODULES]}\""
sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

# replace base and udev with systemd... confirm no sideffects?
#KEY=HOOKS; VALUE='"base udev autodetect modconf console keyboard block encrypt filesystems"'
#sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

mkinitcpio -p linux

:""<< \
-------------------------------------------------------------------------------
BOOTLOADER
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
PASSWORDS, NEW USER SETUP
-------------------------------------------------------------------------------

# root password
#passwd

# new user (only reason we needed to mount the new encrypted /home earlier)
useradd -m -g users -G wheel -s /bin/bash ${CONFIG[USERNAME]}

# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!
#passwd es

# allow wheel
#visudo
cp /etc/sudoers.d /var/tmp/sudoers.new
echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /var/tmp/sudoers.wheel
visudo -cf /var/tmp/sudoers.wheel && mv /var/tmp/sudoers.wheel /etc/sudoers.d/wheel || echo "ERROR updating sudoers; no change made"

:""<< \
-------------------------------------------------------------------------------
POST USER LOGIN INSTALLS
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
EXIT CHROOT FOR CLEANUP
-------------------------------------------------------------------------------
exit

# vim: set filetype=sh :
