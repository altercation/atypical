#!/usr/bin/zsh

typeset -r USAGE="
-------------------------------------------------------------------------------

atypical - A Typical Arch Linux Install Script

Author:

    Ethan Schoonover <es@ethanschoonover.com>

Usage:

    atypical manifest-filename
    atypical /full/absolute/path/to/manifest-filename
    atypical http://url/of/file/to/curl

Options:

    -d, --debug     Debug level 1: show extra command output
    -dd, --ddebug   Debug level 2: add verbose script execution option
    -ddd, --dddebug Debug level 3: add xtrace script execution option

Examples:

    atypical gnome_system
    atypical xmonad_laptop
    atypical /root/atypical/manifests/quick_modified_gnome_system
    atypical http://myserver.com/my_laptop_manifest

Related:

See manifest subdirectory for manifest file content details.

-------------------------------------------------------------------------------
"
:<< \
-------------------------------------------------------------------------------
Frontmatter
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
SCRIPT_ROOT="${SCRIPT_PATH:h}"
for _common in ${SCRIPT_ROOT}/functions/common/*; do source ${_common}; done;

# root?
true && :"" <<< "Beginning $SCRIPT_NAME installer" \
# [[ "$(whoami)" == "root" ]] \
#     && :"" <<<"\nBeginning $SCRIPT_NAME installer" \
#     || errorLog "Must be root to run this install script."

:''<< \
-------------------------------------------------------------------------------
Setting up installer environment
-------------------------------------------------------------------------------
# initial declarations
typeset -Ax SCRIPT DIR FUNC CONFIG INSTALLER USER STORAGE

# default value for new system install mount point, chroot
MOUNTROOT="/mnt"

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical manifest file
-------------------------------------------------------------------------------
# If the manifest file hasn't been specified as arg 1 on the command line, fail
[[ -n ${MANIFEST:=${1:-}} ]] \
    || { errorPrint "NO MANIFEST SPECIFIED" && usage 1; }

# source remote or create absolute filepath
if [[ "$MANIFEST" =~ "(http|ftp)s?:.*" ]]; then
    { curl -#L $MANIFEST -o $TMPDIR/manifest } ioLog \
    && { successLog "Retrieved remote manifest file.";
         MANIFEST="$TMPDIR/manifest"; } \
    || { errorLog "Failed to retrieve remote manifest. Check URL:" ||
         errorLog "$MANIFEST"; }
fi

# create absolute path
[[ "${MANIFEST:0:1}" == "/" ]] || MANIFEST="$SCRIPT_ROOT/manifests/$MANIFEST"

# confirm manifest exists, then source
[[ -f "$MANIFEST" ]] || errorLog "Could not find manifest at $MANIFEST."
{ source "$MANIFEST" } ioLog \
    || errorLog "Error while reading manifest: check formating and values."

# if custom root set, set a convenience variable
[[ -z "${CUSTOM_ROOT:-}" ]] || CUSTOM=true

# If the manifest contains a SCRIPT[CUSTOM]="http://repo.url/goes/here" style
# declaration, that url is used as a git repository "root". This is then
# cloned locally.
[[ ! "${CUSTOM_ROOT:-}" =~ "(https?|git):.*" ]] || {
        progressLog "Cloning custom script repository";
        { git clone --progress "${CUSTOM_ROOT:-}" "$TMPDIR/custom"; } ioLog \
        && { successLog "Done.";
             CUSTOM_ROOT="$TMPDIR/custom"; } \
        || { errorLog "Failed." }
    }

# If a custom root has been set in the manifest and successfully cloned, its
# subdirectories are scanned and all files added as autoload functions that
# take precedence over built-in autoloaded functions. thus any atypical
# function or installer can (and will) be overridden by a user file of the
# same name.
# if [[ "${${SCRIPT[CUSTOM_ROOT]:-}:0:1}" == "/" ]]; then
#     DATAPATHS[CUSTOM_MANIFESTS]="${SCRIPT[CUSTOM_ROOT]}/manifests"
#     DATAPATHS[CUSTOM_STORAGE]="${SCRIPT[CUSTOM_ROOT]}/storage"
#     AUTOPATHS[CUSTOM_FUNCTIONS]="${SCRIPT[CUSTOM_ROOT]}/scripts"
#     AUTOPATHS[CUSTOM_INSTALLERS_PATH]="${SCRIPT[CUSTOM_ROOT]}/installers"
#     AUTOPATHS[CUSTOM_USER_PATH]="${SCRIPT[CUSTOM_ROOT]}/scripts"
#     autoInit "${(@v)AUTOPATHS[(I)CUSTOM*]}" "${SCRIPT[CUSTOM_ROOT]}"
#     teeLog "Successfully set custom script source as listed in manifest."
# elif [[ -n "${SCRIPT[CUSTOM_ROOT]:-}" ]]; then
#     errLog "Failed to source/set new script source as listed in manifest."
# fi
# exit

:""<< \
-------------------------------------------------------------------------------
Autoloading installer functions
-------------------------------------------------------------------------------
# autoload all functions, custom second so that it is first in line in fpath
for _root in $SCRIPT_ROOT ${CUSTOM_ROOT:-}; do
    fpath=($_root/{installers,functions,user} "${fpath[@]}")
    for _func in $_root/{installers,functions,user}/**~common/*(.); do
        autoload ${_func:t}
    done
done
successLog "Loaded installer functions."

:""<< \
-------------------------------------------------------------------------------
Preparing storage
-------------------------------------------------------------------------------
# expects STORAGE[TABLE] as scalar value, either filename or actual table data
# check that we have something in the STORAGE[TABLE] value and if we do then
# convert to array for easy multiline check
[[ -n "${STORAGE[TABLE]:-}" ]] \
    && STORAGE_TABLE_DATA=(${(f)STORAGE[TABLE]:-}) \
    || errorLog "No storage table data / filename present in manifest."

# single line value, assume is filename for storage table; check & read
if [[ -z "${STORAGE_TABLE_DATA[2]:-}" ]]; then

    # set up file path for custom storage
    if ${CUSTOM:-false}; then # custom
        if [[ -f "${STORAGE_FILE::=${CUSTOM_ROOT:-}/storage/${STORAGE_TABLE_DATA}}" ]];
        then
            printLog \
            "Using custom storage table definition: $STORAGE_TABLE_DATA."
        elif [[ -f "${STORAGE_FILE::=${SCRIPT_ROOT:-}/storage/${STORAGE_TABLE_DATA}}" ]];
        then
            printLog \
            "No custom storage table file named $STORAGE_TABLE_DATA." \
            "\nUsing default storage table definition at $STORAGE_FILE."
        else
            errorLog \
            "ERROR: No custom storage table file named $STORAGE_TABLE_DATA." \
            "\nNo matching default storage table definition found in " \
            "$SCRIPT_ROOT/storage"
        fi
    elif [[ -f "${STORAGE_FILE::=${SCRIPT_ROOT:-}/storage/${STORAGE_TABLE_DATA}}" ]];
    then
            printLog \
            "Using default storage table named $STORAGE_TABLE_DATA " \
            "at $STORAGE_FILE."
    else
            errorLog \
            "No storage table named $STORAGE_TABLE_DATA found " \
            "in $SCRIPT_ROOT/storage"
    fi

    # write file contents to value, stripping comment lines
    egrep -v "^#|^$" "${STORAGE_FILE}" > $TMPDIR/STORAGE_TABLE \
        || errorLog "Failed to read storage file $STORAGE_FILE"

    # if successfully processed, read it into the correct scalar variable
    STORAGE[TABLE]="$(cat $TMPDIR/STORAGE_TABLE)"

    # cleanup
    rm $TMPDIR/STORAGE_TABLE &>/dev/null

    # include in log and debug output
    debugLog "${STORAGE[TABLE]}"

fi

# call atypical's init-storage with actual storage table data
# (init-storage takes either a file path or table data, but we've normalized
# to table data here)
init-storage -s "${STORAGE[TABLE]}"
exit

:""<< \
-------------------------------------------------------------------------------
INSTALL BASE SYSTEM
-------------------------------------------------------------------------------

# including base-devel by default
pacstrap $MOUNT_ROOT base base-devel

# generate fstab
genfstab -L $MOUNT_ROOT > $MOUNT_ROOT/etc/fstab

:""<< \
-------------------------------------------------------------------------------
INSTALL BOOT LOADER??? NOT HERE?
-------------------------------------------------------------------------------
refind-install --root $MOUNT_ROOT
mv $MOUNT_ROOT/boot/EFI/refind $MOUNT_ROOT/boot/EFI/BOOT
mv $MOUNT_ROOT/boot/EFI/BOOT/refind_x86.efi $MOUNT_ROOT/boot/EFI/BOOT/bootx86.efi

:""<< \
-------------------------------------------------------------------------------
CREATE CHROOT SCRIPT; CHROOT, COMPLETION, CLEANUP
-------------------------------------------------------------------------------
# extract everything after this section with necessary variables prefixed

# initialize new script
CHROOT_SCRIPT_NAME="${SCRIPT_NAME}-chroot"
CHROOT_SCRIPT_PATH="$MOUNT_ROOT/$CHROOT_SCRIPT_NAME"
echo "#!/usr/bin/zsh" >> "$CHROOT_SCRIPT_PATH"

# dump required variables and arrays into new script
function {
for _param
do
    typeset -p $_param >> "$CHROOT_SCRIPT_PATH"
done
} INSTALL CONFIG MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS STORAGE_RECORDS

# dump functions into script
cat ${SCRIPT_ROOT}/scripts/functions >> "$CHROOT_SCRIPT_PATH"

# dump remainder of file into chroot script
sed -n "/>\{10\}/,$ p" "$SCRIPT_PATH" >> "$CHROOT_SCRIPT_PATH"
chmod +x "$CHROOT_SCRIPT_PATH"

#DEBUG
print "CHECK CHROOT SCRIPT"
exit

# chroot
arch-chroot $MOUNT_ROOT "$CHROOT_SCRIPT_NAME"

# post chroot cleanup
rm $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
umount -R $MOUNT_ROOT/boot; umount -R $MOUNT_ROOT; cryptsetup close crypt
echo "check mkinitcpio.conf, efi boot params, etc. and then reboot"; exit
#reboot

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> CHROOT TRIM LINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

:""<< \
-------------------------------------------------------------------------------
INSTALL OTHER BASIC SYSTEM-RELATED PACKAGES
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
SYSTEM CONFIG - LOCALE, TIME, HOSTNAME
-------------------------------------------------------------------------------
export LANG=${CONFIG[LOCALE-CONF]}
print "${CONFIG[LOCALE-GEN]}" >> /etc/locale.gen; locale-gen
print "${CONFIG[LOCALE-CONF]}" > /etc/locale.conf
print "FONT=${CONFIG[CONSOLEFONT]}" >> /etc/vconsole.conf
ln -s /usr/share/zoneinfo/${CONFIG[TIMEZONE]} /etc/localtime
hwclock --systohc --utc
print "${CONFIG[HOSTNAME]}" > /etc/hostname

:""<< \
-------------------------------------------------------------------------------
CLI
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
INSTALL ${PACKAGES[VIDEO]:-}
INSTALL ${PACKAGES[GUI]:-}
enableServices ${SERVICES[GUI]:-}

:""<< \
-------------------------------------------------------------------------------
INITRAMFS
-------------------------------------------------------------------------------
# configure initramfs
FILE=/etc/mkinitcpio.conf

KEY=MODULES; VALUE="\"${CONFIG[INIT_MODULES]}\""
sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

# replace base and udev with systemd... confirm no sideffects?
#KEY=HOOKS; VALUE='"base udev autodetect modconf console keyboard block encrypt filesystems"'
#sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

mkinitcpio -p linux

:""<< \
-------------------------------------------------------------------------------
BOOTLOADER
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
PASSWORDS, NEW USER SETUP
-------------------------------------------------------------------------------

# root password
#passwd

# new user (only reason we needed to mount the new encrypted /home earlier)
useradd -m -g users -G wheel -s /bin/bash ${CONFIG[USERNAME]}

# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!
#passwd es

# allow wheel
#visudo
cp /etc/sudoers.d /var/tmp/sudoers.new
echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /var/tmp/sudoers.wheel
visudo -cf /var/tmp/sudoers.wheel && mv /var/tmp/sudoers.wheel /etc/sudoers.d/wheel || echo "ERROR updating sudoers; no change made"

:""<< \
-------------------------------------------------------------------------------
POST USER LOGIN INSTALLS
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
EXIT CHROOT FOR CLEANUP
-------------------------------------------------------------------------------
exit

# vim: set filetype=sh :
