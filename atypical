#!/usr/bin/zsh

:<< \
-----------------------------------------------------------------------
atypical

Archlinux - A Typical Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

atypical my_manifest_filename

Takes a filename (not path) as a single argument. This file is then
sourced from any available subdirectory of the script parent directory.
The file is assumed to be a manifest file which contains a list of
patterns to load from the patterns subdirectory. This manifest file
would contain a single variable assigment like this:

MANIFEST=(storage_1_clear_btrfs_simple xorg_full video_intel gui_xmonad utils_file)

With no arguments, atypical uses defaults as listed below in the defaults section.
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
FRONTMATTER
-----------------------------------------------------------------------

# script options
setopt ERR_EXIT NO_UNSET EXTENDED_GLOB #VERBOSE XTRACE
#setopt ERR_EXIT NO_UNSET EXTENDED_GLOB VERBOSE XTRACE

# declaration
typeset -Ag CONFIG INSTALLER \
            MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS
typeset -ag MODULES MANIFEST BOOTOPTS STORAGE

# environment
MOUNT_ROOT=/mnt
SCRIPT=$(readlink -f "$0"); SCRIPT_PATH=$(dirname "$SCRIPT")
fpath=(${SCRIPT_PATH}/installers $fpath)

# source externals
source ${SCRIPT_PATH}/scripts/functions
MANIFEST_PATH="${SCRIPT_PATH}/manifests/$1"
if [ -e "${MANIFEST_PATH}" ]; then
    source "${MANIFEST_PATH}"
else
    echo "No manifest found at ${MANIFEST_PATH}; exiting"
    exit
fi

# system
RAM=$(detectMemory)

:<< \
-----------------------------------------------------------------------
STORAGE OPTIONS
-----------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# USE COLUMN NAME VARIABLES WITH UNDERSCORE PREFIX FOR RUN TIME REPLACEMENT
# e.g. $_LABEL in the scalar values below will be replaced with the
# LABEL field value for the specific block item at run time

MKFS_OPTIONS[COMMON]=''
MKFS_OPTIONS[SSD]=''
MKFS_OPTIONS[FAT]='-F32 -n $_LABEL'
MKFS_OPTIONS[FAT,SSD]=''
MKFS_OPTIONS[BTRFS]='--force --label $_LABEL'
MKFS_OPTIONS[BTRFS,SSD]='--metadata single' # see man mkfs.btrfs

MOUNT_OPTIONS[COMMON]='rw'
MOUNT_OPTIONS[SSD]='noatime'
MOUNT_OPTIONS[BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
MOUNT_OPTIONS[BTRFS,SSD]='ssd,discard_space'
MOUNT_OPTIONS[LUKS]=''

# Note that --force-password allows weak passphrases (for testing only)
LUKS_OPTIONS[FORMAT_OPTIONS]='--force-password'
LUKS_OPTIONS[OPEN_OPTIONS]=''
LUKS_OPTIONS[OPEN_OPTIONS,SSD]='--allow-discards'

:<< \
-----------------------------------------------------------------------
CHECK FOR ROOT - Customization shouldn't be necessary from here on
-----------------------------------------------------------------------
if [[ "$(whoami)" != "root" ]]; then
    notify "Must be root to run this install script. Exiting."
    #exit
fi

:<< \
'-----------------------------------------------------------------------'
DISK SELECTION
-----------------------------------------------------------------------

# interactively selects installation target and assigns to var DRIVE
#selectInstallTarget DRIVE
DRIVE=dummydrive
notifySection "Installation to $DRIVE beginning..."

:<< \
-----------------------------------------------------------------------
READ & PARSE STORAGE TABLE
-----------------------------------------------------------------------

STORAGE_TABLE_FILEPATH="${SCRIPT_PATH}/storage/${CONFIG[STORAGE]}"
STORAGE_TABLE=("${(@f)$(egrep -v "^#|^$" "${STORAGE_TABLE_FILEPATH}")}")

extractFieldNames   STORAGE_TABLE STORAGE_FIELD_NAMES
extractFieldValues  STORAGE_TABLE STORAGE_FIELD_VALUES
parseTableToRecords STORAGE_FIELD_VALUES \
                    STORAGE_FIELD_NAMES \
                    NUM_STORAGE_RECORDS \
                    STORAGE_RECORD

# If parseTableToRecords found a mismatch in the table formatting
# then it throws an error. Handle it here.
if (( $? > 0 )); then
    print "\n\nERROR: Failed to parse storage table; check table format."
    exit
fi

# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
MOUNT_POINTS=(${(vo)STORAGE_RECORD[(I)*,MOUNT_POINT]})

# Assemble install paths
# Assign the parent device/storage container path to it's children
_partition_index=0
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setCurrentRecordFromTable $_record_index STORAGE_FIELD_NAMES STORAGE_RECORD
    if [[ -z ${_CHILD_OF:-} ]]; then
        (( _partition_index += 1 ))
        BLOCKITEM[${BLOCKITEM_NUM},PARTNUM]=$PARTNUM
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=${DRIVE}${PARTNUM}
    elif [[ ${(L)_PARENT_FSTYPE} == "luks" ]]; then
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=/dev/mapper/${_PARENT_LABEL}
    elif [[ ${(L)_PARENT_FSTYPE} == "btrfs" && ${(L)_FSTYPE} == "btrfs" ]]; then
        # a btrfs subvolume
        # child items must always follow parent items in table for this to work
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=$_PARENT_PATH
        BLOCKITEM[${BLOCKITEM_NUM},BTRFS,SUBVOLUME]=true
    else
        print "Unknown parent/child relationship found for block table entry ${BLOCKITEM_NUM} ($_LABEL)."
        print "Child FSTYPE:  $_FSTYPE"
        print "Parent FSTYPE: $_PARENT_FSTYPE"
        print "Exiting."
        exit
    fi
    unsetCurrentBlockItem

done
exit

# Assemble install paths

PARTNUM=0
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ -z ${_CHILD_OF:-} ]]; then
        (( PARTNUM += 1 ))
        BLOCKITEM[${BLOCKITEM_NUM},PARTNUM]=$PARTNUM
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=${DRIVE}${PARTNUM}
    elif [[ ${(L)_PARENT_FSTYPE} == "luks" ]]; then
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=/dev/mapper/${_PARENT_LABEL}
    elif [[ ${(L)_PARENT_FSTYPE} == "btrfs" && ${(L)_FSTYPE} == "btrfs" ]]; then
        # a btrfs subvolume
        # child items must always follow parent items in table for this to work
        BLOCKITEM[${BLOCKITEM_NUM},PATH]=$_PARENT_PATH
        BLOCKITEM[${BLOCKITEM_NUM},BTRFS,SUBVOLUME]=true
    else
        print "Unknown parent/child relationship found for block table entry ${BLOCKITEM_NUM} ($_LABEL)."
        print "Child FSTYPE:  $_FSTYPE"
        print "Parent FSTYPE: $_PARENT_FSTYPE"
        print "Exiting."
        exit
    fi
    unsetCurrentBlockItem
done

# Create partitioning command
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ -n ${_CODE:-} ]]; then 
        [[ ${(L)_SIZE} == max ]] && new_cmd="--largest-new=$_PARTNUM" || new_cmd="--new=$_PARTNUM:0:+${_SIZE}"
        [[ ${(L)_LABEL} == boot || ${(L)_LABEL} == efi ]] && eval attr_cmd="--attributes=$_PARTNUM\:set\:0" || attr_cmd="" 
        sgdisk_cmd="${sgdisk_cmd:-} $new_cmd --typecode=$_PARTNUM:${BLOCKITEM[$BLOCKITEM_NUM,CODE]} --change-name=$_PARTNUM:${BLOCKITEM[$BLOCKITEM_NUM,LABEL]} $attr_cmd"
    fi
    unsetCurrentBlockItem
done
sgdisk_cmd="${sgdisk_cmd:-} ${DRIVE}"

# Test Output of all table key value pairs
#print "$(for BLOCKITEMKEY in ${(k)BLOCKITEM}; do echo -e "$BLOCKITEMKEY:\t\t${BLOCKITEM[$BLOCKITEMKEY]}"; done)" | sort
#echo "sgdisk $sgdisk_cmd"
#exit

:<< \
'-----------------------------------------------------------------------'
DISK PREPARATION

# debugging crypto close
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ ${(L)_FSTYPE} == luks ]]; then
        cryptsetup close $_LABEL || :
    fi
    unsetCurrentBlockItem
done
-----------------------------------------------------------------------

# Erase drive, create new GPT structure, and create partitions
sgdisk --zap-all ${DRIVE}
sgdisk --clear ${DRIVE}
eval sgdisk $sgdisk_cmd

:<< \
'-----------------------------------------------------------------------'
ENCRYPT STORAGE
-----------------------------------------------------------------------

# Check if we need encryption
ENCRYPTION=false
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    [[ ${(L)_FSTYPE} == luks ]] && ENCRYPTION=true || :
    unsetCurrentBlockItem
done

if [[ $ENCRYPTION == true ]]; then

    # Get passphrase
    setPassphrase PASSPHRASE "disk encryption passphrase"
    #PASSPHRASE=DEBUG

    # Encrypt partitions
    for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
        setCurrentBlockItem $BLOCKITEM_NUM
        if [[ ${(L)_FSTYPE} == luks ]]; then
        print "Encrypting $_LABEL on $_PATH ... "
            print -r "$PASSPHRASE" | cryptsetup ${LUKS_OPTIONS[FORMAT_OPTIONS]:-} luksFormat $_PATH
            print -r "$PASSPHRASE" | cryptsetup open ${LUKS_OPTIONS[OPEN_OPTIONS]:-} ${SSD:-${LUKS_OPTIONS[OPEN_OPTIONS,SSD]:-}} $_PATH $_LABEL
        fi
        unsetCurrentBlockItem
    done

    # Cleanup
    unset PASSPHRASE

fi

:<< \
'-----------------------------------------------------------------------'
MAKE FILESYSTEMS
-----------------------------------------------------------------------

# FIRST PASS: isn't luks, doesn't have "child of"
# (so should be our top level physical partitions)
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ ${(L)_FSTYPE} != luks && -z ${_CHILD_OF:-} ]]; then
        MKFS_OPTIONS_COMPILED="${MKFS_OPTIONS[${(U)_FSTYPE}]:-} ${MKFS_OPTIONS[${(U)_FSTYPE},SSD]:-} ${_MKFS_OPTIONS:-}"
        eval mkfs.${(L)_FSTYPE} $MKFS_OPTIONS_COMPILED ${_PATH}
    fi
    unsetCurrentBlockItem
done

# SECOND PASS: isn't luks itself but is "child of" luks
# (filesystems installed on luks)
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ ${(L)_FSTYPE} != luks && ${(L)_PARENT_FSTYPE:-} == luks ]]; then
        if [[ ${(L)_FSTYPE} == swap  ]]; then
            eval mkswap --label $_LABEL $_PATH
            eval swapon -L $_LABEL
        else
            MKFS_OPTIONS_COMPILED="${MKFS_OPTIONS[${(U)_FSTYPE}]:-} ${MKFS_OPTIONS[${(U)_FSTYPE},SSD]:-} ${_MKFS_OPTIONS:-}"
            eval mkfs.${(L)_FSTYPE} $MKFS_OPTIONS_COMPILED ${_PATH}
        fi
    fi
    unsetCurrentBlockItem
done

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for BLOCKITEM_NUM in {1..$NUM_OF_STORAGE_ITEMS}; do
    setCurrentBlockItem $BLOCKITEM_NUM
    if [[ ${(L)_FSTYPE} != luks && -n ${_CHILD_OF:-} && ${(L)_PARENT_FSTYPE} != luks ]]; then
        if [[ ${(L)_FSTYPE} == btrfs && ${(L)_PARENT_FSTYPE} == btrfs ]]; then
            # a btrfs subvolume
            mount $_PARENT_PATH $MOUNT_ROOT
            if [[ -n ${_MOUNT_POINT#/} && -n ${_PARENT_MOUNT_POINT:-} ]]; then
            # create the subvolume as a subdirectory of a parent volume that will itself be mounted
                dirname=${_MOUNT_POINT:t}
                dirpath=${_MOUNT_POINT:h}
                MOUNT_POINT=${MOUNT_ROOT%/}/${_MOUNT_POINT#/}
                mkdir -p ${MOUNT_POINT:h}
                eval btrfs subvolume create ${MOUNT_POINT%/}/$_LABEL 
            else
            # create the subvolumes as stand alone "peers" on a parent volume that will not itself be mounted
                eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_LABEL"
                eval "BLOCKITEM[$BLOCKITEM_NUM,MOUNT_OPTIONS]=\"${_MOUNT_OPTIONS:-}${_MOUNT_OPTIONS:+,}subvol=$_LABEL\""
                eval "BLOCKITEM[$BLOCKITEM_NUM,MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print "Filesystem of type $_FSTYPE set as child of parent device with filesystem of type $_FSTYPE: No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetCurrentBlockItem
done

# Mount
for MOUNT_POINT in $ALL_MOUNTS; do

    setCurrentBlockItem $BLOCKITEM_NUM_FROM_MOUNT_POINT[$MOUNT_POINT]
    MOUNT_OPTIONS_COMPILED=""

    # build mount option list
    addToCommaList MOUNT_OPTIONS_COMPILED ${_MOUNT_OPTIONS:-} ${MOUNT_OPTIONS[COMMON]:-} ${MOUNT_OPTIONS[${(U)_FSTYPE}]:-}
    if [[ -n ${SSD:-} ]]; then addToCommaList MOUNT_OPTIONS_COMPILED ${MOUNT_OPTIONS[SSD]:-} ${MOUNT_OPTIONS[${(U)_FSTYPE},SSD]:-}; fi
    if checkForLuksAncestor $_LABEL; then addToCommaList MOUNT_OPTIONS_COMPILED ${MOUNT_OPTIONS[LUKS]:-}; fi

    # take table mount point and combine with system install mount point
    MOUNT_POINT=${MOUNT_ROOT%/}/${_MOUNT_POINT#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_PARENT_MOUNT_POINT:-} ]]; then
        PARENT_MOUNT_POINT=${MOUNT_ROOT%/}/${_PARENT_MOUNT_POINT#/}
        if findmnt $PARENT_MOUNT_POINT &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes are already present... don't need to do anything here?
            #mkdir -p ${MOUNT_POINT}
            :
        else
            print "Parent device not mounted but required for mounting of filesystem (likely a btrfs subvolume)."
            print "Parent: $_PARENT_LABEL  Attempting to mount: $_LABEL"
            exit
        fi
    fi
    #mount $MOUNT_OPTIONS ${_PATH} ${MOUNT_ROOT%/}/${_MOUNT_POINT#/}
    [[ -n ${_MOUNTED_BTRFS_SUBVOL:-} ]] && LABEL=$_PARENT_LABEL || LABEL=$_LABEL
    MOUNT_POINT=${MOUNT_ROOT%/}/${_MOUNT_POINT#/}
    mkdir -p ${MOUNT_POINT}
    eval "mount -o $MOUNT_OPTIONS LABEL=$LABEL $MOUNT_POINT"
    unsetCurrentBlockItem

done

# Make fstab
#mkdir -p ${MOUNT_ROOT%/}/etc

:<< \
-----------------------------------------------------------------------
INSTALL BASE SYSTEM
-----------------------------------------------------------------------
pacstrap $MOUNT_ROOT base #base-devel
genfstab -L $MOUNT_ROOT > $MOUNT_ROOT/etc/fstab
refind-install --root $MOUNT_ROOT
mv $MOUNT_ROOT/boot/EFI/refind $MOUNT_ROOT/boot/EFI/BOOT
mv $MOUNT_ROOT/boot/EFI/BOOT/refind_x86.efi $MOUNT_ROOT/boot/EFI/BOOT/bootx86.efi

:<< \
'-----------------------------------------------------------------------'
CREATE CHROOT SCRIPT; CHROOT, COMPLETION, CLEANUP
-----------------------------------------------------------------------
# extract everything after this section with necessary variables prefixed
CHROOT_SCRIPT_NAME=atypical-chroot
echo "#!/usr/bin/zsh" >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
typeset -f INSTALL >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
echo "declare -A CONFIG" >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
cat ${SCRIPT_PATH}/scripts/functions >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME

function {
	#for key in "${!CONFIG[@]}"
	for arrayname
	do
		for key in "${!$arrayname[@]}"
		do    
		    #echo "CONFIG[$key]=\"${CONFIG[$key]}\"" >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
		    echo "$arrayname[$key]=\"${$arrayname[$key]}\"" >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
		done
	done
} CONFIG MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS

sed -n "/>\{10\}/,$ p" "$0" >> $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
chmod +x $MOUNT_ROOT/$CHROOT_SCRIPT_NAME

arch-chroot $MOUNT_ROOT $CHROOT_SCRIPT_NAME; rm $MOUNT_ROOT/$CHROOT_SCRIPT_NAME;
umount -R $MOUNT_ROOT/boot; umount -R $MOUNT_ROOT; cryptsetup close crypt
echo "check mkinitcpio.conf, efi boot params, etc. and then reboot"; exit
#reboot

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> CHROOT TRIM LINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

:<< \
'-----------------------------------------------------------------------'
INSTALL OTHER BASIC SYSTEM-RELATED PACKAGES
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
SYSTEM CONFIG - LOCALE, TIME, HOSTNAME
-----------------------------------------------------------------------
export LANG=${CONFIG[LOCALE-CONF]}
print "${CONFIG[LOCALE-GEN]}" >> /etc/locale.gen; locale-gen
print "${CONFIG[LOCALE-CONF]}" > /etc/locale.conf
print "FONT=${CONFIG[CONSOLEFONT]}" >> /etc/vconsole.conf
ln -s /usr/share/zoneinfo/${CONFIG[TIMEZONE]} /etc/localtime
hwclock --systohc --utc
print "${CONFIG[HOSTNAME]}" > /etc/hostname

:<< \
'-----------------------------------------------------------------------'
CLI
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
GUI
-----------------------------------------------------------------------
INSTALL ${PACKAGES[VIDEO]:-}
INSTALL ${PACKAGES[GUI]:-}
enableServices ${SERVICES[GUI]:-}

:<< \
'-----------------------------------------------------------------------'
INITRAMFS
-----------------------------------------------------------------------
# configure initramfs
FILE=/etc/mkinitcpio.conf

KEY=MODULES; VALUE="\"${CONFIG[INIT_MODULES]}\""
sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

# replace base and udev with systemd... confirm no sideffects?
#KEY=HOOKS; VALUE='"base udev autodetect modconf console keyboard block encrypt filesystems"'
#sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

mkinitcpio -p linux

:<< \
'-----------------------------------------------------------------------'
BOOTLOADER
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
PASSWORDS, NEW USER SETUP
-----------------------------------------------------------------------

# root password
#passwd

# new user (only reason we needed to mount the new encrypted /home earlier)
useradd -m -g users -G wheel -s /bin/bash ${CONFIG[USERNAME]}

# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!
#passwd es

# allow wheel
#visudo
cp /etc/sudoers.d /var/tmp/sudoers.new
echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /var/tmp/sudoers.wheel
visudo -cf /var/tmp/sudoers.wheel && mv /var/tmp/sudoers.wheel /etc/sudoers.d/wheel || echo "ERROR updating sudoers; no change made"

:<< \
'-----------------------------------------------------------------------'
POST USER LOGIN INSTALLS
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
EXIT CHROOT FOR CLEANUP
-----------------------------------------------------------------------
exit

