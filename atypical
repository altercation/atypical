#!/usr/bin/zsh

usage () {<< \
-------------------------------------------------------------------------------

atypical

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

atypical manifest-filename
atypical /full/absolute/path/to/manifest-filename
atypical http://url/of/file/to/curl

Options:

-d, --debug     Debug level 1: show extra command output
-dd, --ddebug   Debug level 2: add verbose script execution option
-ddd, --dddebug Debug level 3: add xtrace script execution option

Examples:

atypical gnome_system
atypical xmonad_laptop
atypical /root/atypical/manifests/quick_modified_gnome_system
atypical http://myserver.com/my_laptop_manifest

(see manifest subdirectory for manifest file content details)

-------------------------------------------------------------------------------
exit ${1:-0}; }

:<< \
-------------------------------------------------------------------------------
Frontmatter
-------------------------------------------------------------------------------
# simple opt parsing since we only use debug flags
# -d, --debug, -dd, --ddebug, -ddd, --dddebug
[[ ${1:-} == *-ddd* ]] && DDDEBUG=true
[[ ${1:-} == *-dd* ]]  && DDEBUG=true
[[ ${1:-} == *-d* ]]   && DEBUG=true && shift

# script options: good habits like no_unset and ensuring we fail out if
# there are any errors... error handling must be present where "acceptable"
# error states are anticipated
setopt ERR_RETURN NO_UNSET GLOBAL_EXPORT EXTENDED_GLOB \
       ${DDEBUG:+VERBOSE} ${DDDEBUG:+XTRACE}

:<< \
-------------------------------------------------------------------------------
Logging functions
-------------------------------------------------------------------------------
# set up log file and fd
rm "${LOGFILE:=/tmp/atypical.log}" &>/dev/null || true
integer LOGFD; exec {LOGFD} >> "${LOGFILE}"

# teeLog: tee like logging. Examples:
#     teeLog "message"
#     teeLog -w "wrapped message"
#     print "message" | teeLog
#     teeLog <<< "message" 
#     teeLog -w <<EOF
#     "wrapped message" 
#     EOF
teeLog () { [[ "${1:-}" == "-w" ]] && w="${(r:80::--:):-}" && shift || w=""
    m=("${@:-$(while read line; do print $line; done)}");
    print -- "${w:-}${w:+\n}${(@F)m:-}${w:+\n}${w:-}" >&1 >&$LOGFD 2>&1;}

# semantic comments:
# Without these aliases, the semantic comment style is ignored silently
# as "just a comment". With these aliases, the semantic comment content
# is output to the console and logged.
alias -g  :\'\'='teeLog'
alias -g  :\"\"='teeLog -w'

# ioLog* is used herein to allow stderr messages to be captured and also
# allow errors to be handled by ERR_RETURN, TRAPERR/TRAPZERR. Examples:
#
#     (print "this will succeed"; this_will_fail ) ioLogOutErr
#         will allow both stdout and stderr messages out to console
#         and also log them to the logfile; the error will be handled
#         normally by the script (ignored, exited, trapped, etc.)
#
#     (print "this will succeed"; this_will_fail ) ioLogOut
#         will allow only stdout to console but will still log both
#         stdout and stderr to the logfile; the error will be handled
#         normally by the script (ignored, exited, trapped, etc.)
#
#     (print "this will succeed"; this_will_fail ) ioLogNull
#         will allow neither stdout nor stderr out to the console but
#         will log both to the logfile; the error will be handled
#         normally by the script (ignored, exited, trapped, etc.)
alias ioLogOutErr=">&1 >&$LOGFD 2>&1"
alias ioLogOut=">&1 >&$LOGFD 2>&$LOGFD"
alias ioLogNull=">&$LOGFD 2>&$LOGFD"
[[ -n ${DEBUG:-} ]] && \
alias ioLogOut=">&1 >&$LOGFD 2>&1" && \
alias ioLogNull=">&1 >&$LOGFD 2>&1"

:''<< \
-------------------------------------------------------------------------------
Setting up installer, beginning installation...
-------------------------------------------------------------------------------
# initial declarations
typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

# make sure we know where the real script (and subdirectories) are
SCRIPT[NAME]="${${_PATH:=$(readlink -f "$0")}:t}" SCRIPT[ROOT]="${_PATH:h}"

# default values for new system mount point, temp files
MOUNTROOT="/mnt"
TMPDIR="$(mktemp -d "/tmp/${SCRIPT[NAME]}-XXXXXX")"

# zsh trap functions
cleanup  () { [[ -n $LOGFD ]] && exec {LOGFD}>&- && unset $LOGFD;
              [[ -d "$TMPDIR" ]] && rm -rf "$TMPDIR"; }

# list trap to keep it from handling subshell exits
trap ' print "\nEXITING INSTALLER"; cleanup;' EXIT

# function trap to handle subshell errors
TRAPZERR () { local _cmd=$_ _code=$?;
              print "\nUNHANDLED ERROR in command $_cmd\n(see $LOGFILE)\n" \
              2>&$LOGFD; cleanup; exit 1; }

exitWith () { print "$@"; exit 0; }
failWith () { print "\n${(U)@}"; exit 1; }

# helper function to set up autoload functions by scanning directories
autoInit () { for _newpath; do [[ -d "$_newpath" ]] && \
    fpath=("$_newpath" "${fpath[@]}") _newfuncs=(${_newpath}/**/*(.))
    for _func in "${(@)_newfuncs}"; do autoload ${_func:t}; done; done; }

# our "data" directories (non executable file content)
DATAPATHS[MANIFESTS]="${SCRIPT[ROOT]}/manifests"
DATAPATHS[STORAGE]="${SCRIPT[ROOT]}/storage"

# our initial built-in function directories
AUTOPATHS[INSTALLERS]="${SCRIPT[ROOT]}/installers"
AUTOPATHS[FUNCTIONS]="${SCRIPT[ROOT]}/functions"
AUTOPATHS[USER]="${SCRIPT[ROOT]}/user"

# all files in directories (and recursively scanned subdirectories) listed in
# AUTOPATHS will be set as autoload functions
autoInit "${(@)AUTOPATHS}"

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical manifest file
-------------------------------------------------------------------------------
# If the manifest file hasn't been specified as arg 1 on the command line, fail
if [[ -z ${MANIFEST[FILE]:=${1:-}} ]]; then
    teeLog "MANIFEST FILE NOT SPECIFIED" && usage 1
fi

# Make sure we can load the file. sourceFile will source local manifests
# in the default manifests subdirectory of the atypical directory, or will
# load any absolute path provided. Additionally, it will download a remote
# manifest from a given URL.
if sourceFile "${MANIFEST[FILE]}" "${SCRIPT[ROOT]}/manifests"; then
    teeLog "Loaded manifest successfully..."
else
    teeLog "Failure loading manifest..."
    return 1
fi

# If the manifest contains a SCRIPT[CUSTOM]="http://repo.url/goes/here" style
# declaration, that url is used as a git repository "root". This is then
# cloned locally.
if [[ "${SCRIPT[CUSTOM_ROOT]:-}" =~ "(https?|git):.*" ]]; then
    teeLog "Cloning custom script repository..."
    (git clone --progress "${SCRIPT[CUSTOM_ROOT]}" "$TMPDIR/custom") ioLogNull
    if (( $? == 0 )); then
        SCRIPT[CUSTOM_ROOT]="$TMPDIR/custom"
        teeLog "Successfully cloned custom script respository"
    else
        errLog "FAILED to clone custom script respository"
    fi
fi

# If a custom root has been set in the manifest and successfully cloned, its
# subdirectories are scanned and all files added as autoload functions that
# take precedence over built-in autoloaded functions. thus any atypical
# function or installer can (and will) be overridden by a user file of the
# same name.
if [[ "${${SCRIPT[CUSTOM_ROOT]:-}:0:1}" == "/" ]]; then
    DATAPATHS[CUSTOM_MANIFESTS]="${SCRIPT[CUSTOM_ROOT]}/manifests"
    DATAPATHS[CUSTOM_STORAGE]="${SCRIPT[CUSTOM_ROOT]}/storage"
    AUTOPATHS[CUSTOM_FUNCTIONS]="${SCRIPT[CUSTOM_ROOT]}/scripts"
    AUTOPATHS[CUSTOM_INSTALLERS_PATH]="${SCRIPT[CUSTOM_ROOT]}/installers"
    AUTOPATHS[CUSTOM_USER_PATH]="${SCRIPT[CUSTOM_ROOT]}/scripts"
    autoInit "${(@v)AUTOPATHS[(I)CUSTOM*]}" "${SCRIPT[CUSTOM_ROOT]}"
    teeLog "Successfully set custom script source as listed in manifest."
elif [[ -n "${SCRIPT[CUSTOM_ROOT]:-}" ]]; then
    errLog "Failed to source/set new script source as listed in manifest."
fi

:""<< \
-------------------------------------------------------------------------------
Preparing storage
-------------------------------------------------------------------------------
# expects STORAGE[TABLE] as scalar value, either filename or actual table data
# check that we have something in the STORAGE[TABLE] value and if we do then
# convert to array for easy multiline check
if [[ -n "${STORAGE[TABLE]:-}" ]]; then
    STORAGE_TABLE_DATA=(${(f)STORAGE[TABLE]:-})
else
    failWith "No storage table data / filename present in manifest."
fi

# single line value, assume is filename for storage table; check & read
if [[ -z "${STORAGE_TABLE_DATA[2]:-}" ]]; then

    # set up file path for custom storage
    STORAGE_FILE="${DATAPATHS[CUSTOM_STORAGE]:-}/${STORAGE_TABLE_DATA}"

    # if missing, then fallback to built in
    [[ -f "${STORAGE_FILE}" ]] \
    || STORAGE_FILE="${DATAPATHS[STORAGE]}/${STORAGE_TABLE_DATA}"

    # if still missing, we have a problem with a missing file or bad filename
    [[ -f "${STORAGE_FILE}" ]] \
    || failWith "Storage table file not found at $STORAGE_FILE"

    # write file contents to value, stripping comment lines
    egrep -v "^#|^$" "${STORAGE_FILE}" > $TMPDIR/STORAGE_TABLE \
    || failWith "Failed to read storage file $STORAGE_FILE"

    # if we successfully processed, read it into the correct scalar variable
    STORAGE[TABLE]="$(cat $TMPDIR/STORAGE_TABLE)"

    # cleanup
    rm $TMPDIR/STORAGE_TABLE &>/dev/null

fi

# call atypical's init-storage with whatever the current value is
# (init-storage takes either a file path or table data, but we've normalized
# to table data here)
init-storage "${STORAGE[TABLE]}"
print "in script"
exit

:""<< \
-------------------------------------------------------------------------------
INSTALL BASE SYSTEM
-------------------------------------------------------------------------------

# including base-devel by default
pacstrap $MOUNT_ROOT base base-devel

# generate fstab
genfstab -L $MOUNT_ROOT > $MOUNT_ROOT/etc/fstab

:""<< \
-------------------------------------------------------------------------------
INSTALL BOOT LOADER??? NOT HERE?
-------------------------------------------------------------------------------
refind-install --root $MOUNT_ROOT
mv $MOUNT_ROOT/boot/EFI/refind $MOUNT_ROOT/boot/EFI/BOOT
mv $MOUNT_ROOT/boot/EFI/BOOT/refind_x86.efi $MOUNT_ROOT/boot/EFI/BOOT/bootx86.efi

:""<< \
-------------------------------------------------------------------------------
CREATE CHROOT SCRIPT; CHROOT, COMPLETION, CLEANUP
-------------------------------------------------------------------------------
# extract everything after this section with necessary variables prefixed

# initialize new script
CHROOT_SCRIPT_NAME=atypical-chroot
CHROOT_SCRIPT_PATH="$MOUNT_ROOT/$CHROOT_SCRIPT_NAME"
echo "#!/usr/bin/zsh" >> "$CHROOT_SCRIPT_PATH"

# dump required variables and arrays into new script
function {
for _param
do
    typeset -p $_param >> "$CHROOT_SCRIPT_PATH"
done
} INSTALL CONFIG MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS STORAGE_RECORDS

# dump functions into script
cat ${SCRIPT_PATH}/scripts/functions >> "$CHROOT_SCRIPT_PATH"

# dump remainder of file into chroot script
sed -n "/>\{10\}/,$ p" "$SCRIPT_PATH" >> "$CHROOT_SCRIPT_PATH"
chmod +x "$CHROOT_SCRIPT_PATH"

#DEBUG
print "CHECK CHROOT SCRIPT"
exit

# chroot
arch-chroot $MOUNT_ROOT "$CHROOT_SCRIPT_NAME"

# post chroot cleanup
rm $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
umount -R $MOUNT_ROOT/boot; umount -R $MOUNT_ROOT; cryptsetup close crypt
echo "check mkinitcpio.conf, efi boot params, etc. and then reboot"; exit
#reboot

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> CHROOT TRIM LINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

:""<< \
-------------------------------------------------------------------------------
INSTALL OTHER BASIC SYSTEM-RELATED PACKAGES
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
SYSTEM CONFIG - LOCALE, TIME, HOSTNAME
-------------------------------------------------------------------------------
export LANG=${CONFIG[LOCALE-CONF]}
print "${CONFIG[LOCALE-GEN]}" >> /etc/locale.gen; locale-gen
print "${CONFIG[LOCALE-CONF]}" > /etc/locale.conf
print "FONT=${CONFIG[CONSOLEFONT]}" >> /etc/vconsole.conf
ln -s /usr/share/zoneinfo/${CONFIG[TIMEZONE]} /etc/localtime
hwclock --systohc --utc
print "${CONFIG[HOSTNAME]}" > /etc/hostname

:""<< \
-------------------------------------------------------------------------------
CLI
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
INSTALL ${PACKAGES[VIDEO]:-}
INSTALL ${PACKAGES[GUI]:-}
enableServices ${SERVICES[GUI]:-}

:""<< \
-------------------------------------------------------------------------------
INITRAMFS
-------------------------------------------------------------------------------
# configure initramfs
FILE=/etc/mkinitcpio.conf

KEY=MODULES; VALUE="\"${CONFIG[INIT_MODULES]}\""
sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

# replace base and udev with systemd... confirm no sideffects?
#KEY=HOOKS; VALUE='"base udev autodetect modconf console keyboard block encrypt filesystems"'
#sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

mkinitcpio -p linux

:""<< \
-------------------------------------------------------------------------------
BOOTLOADER
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
PASSWORDS, NEW USER SETUP
-------------------------------------------------------------------------------

# root password
#passwd

# new user (only reason we needed to mount the new encrypted /home earlier)
useradd -m -g users -G wheel -s /bin/bash ${CONFIG[USERNAME]}

# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!
#passwd es

# allow wheel
#visudo
cp /etc/sudoers.d /var/tmp/sudoers.new
echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /var/tmp/sudoers.wheel
visudo -cf /var/tmp/sudoers.wheel && mv /var/tmp/sudoers.wheel /etc/sudoers.d/wheel || echo "ERROR updating sudoers; no change made"

:""<< \
-------------------------------------------------------------------------------
POST USER LOGIN INSTALLS
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
EXIT CHROOT FOR CLEANUP
-------------------------------------------------------------------------------
exit
