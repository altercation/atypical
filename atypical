#!/usr/bin/zsh

:<< \
-----------------------------------------------------------------------
atypical

Archlinux - A Typical Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

atypical my_manifest_filename

(see manifests subdirectory)
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
FRONTMATTER
-----------------------------------------------------------------------

# script options
setopt ERR_EXIT NO_UNSET EXTENDED_GLOB #VERBOSE XTRACE
#setopt ERR_EXIT NO_UNSET EXTENDED_GLOB VERBOSE XTRACE

# declaration
typeset -Ag CONFIG INSTALLER \
            MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS
typeset -ag MODULES MANIFEST BOOTOPTS STORAGE

# environment
MOUNT_ROOT=/mnt
SCRIPT=$(readlink -f "$0"); SCRIPT_PATH=$(dirname "$SCRIPT")
fpath=(${SCRIPT_PATH}/installers $fpath)

# check for manifest argument
if [[ -z ${1:-} ]]; then
    print "\nRequires manifest file as parameter. One of:\n"
    ls -1 "$SCRIPT_PATH/manifests"
    print "\nExiting.\n"
    exit 1
fi
    
# source externals
source ${SCRIPT_PATH}/scripts/functions
MANIFEST_PATH="${SCRIPT_PATH}/manifests/$1"
if [ -e "${MANIFEST_PATH}" ]; then
    source "${MANIFEST_PATH}"
else
    echo "No manifest found at ${MANIFEST_PATH}; exiting"
    exit
fi

# system
RAM=$(detectMemory)

:<< \
-----------------------------------------------------------------------
STORAGE OPTIONS
-----------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# USE COLUMN NAME VARIABLES WITH UNDERSCORE PREFIX FOR RUN TIME REPLACEMENT
# e.g. $_LABEL in the scalar values below will be replaced with the
# LABEL field value for the specific block item at run time

# NOTE -- Updated format - using _record_label instead of _LABEL to
# refer to record specific values to be replaced at run time


# labelling a partition with one of these BOOTABLE_LABELS results in
# the partition being marked as a boot parition
BOOTABLE_LABELS=(BOOT EFI)

MKFS_OPTIONS[COMMON]=''
MKFS_OPTIONS[SSD]=''
MKFS_OPTIONS[FAT]='-F32 -n $_record_label'
MKFS_OPTIONS[FAT,SSD]=''
MKFS_OPTIONS[BTRFS]='--force --label $_record_label'
MKFS_OPTIONS[BTRFS,SSD]='--metadata single' # see man mkfs.btrfs

MOUNT_OPTIONS[COMMON]='rw'
MOUNT_OPTIONS[SSD]='noatime'
MOUNT_OPTIONS[BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
MOUNT_OPTIONS[BTRFS,SSD]='ssd,discard_space'
MOUNT_OPTIONS[LUKS]=''

# Note that --force-password allows weak passphrases (for testing only)
LUKS_OPTIONS[FORMAT_OPTIONS]='--force-password'
LUKS_OPTIONS[OPEN_OPTIONS]=''
LUKS_OPTIONS[OPEN_OPTIONS,SSD]='--allow-discards'

:<< \
-----------------------------------------------------------------------
CHECK FOR ROOT - Customization shouldn't be necessary from here on
-----------------------------------------------------------------------
if [[ "$(whoami)" != "root" ]]; then
    notify "Must be root to run this install script. Exiting."
    exit 1
fi

:<< \
'-----------------------------------------------------------------------'
DISK SELECTION
-----------------------------------------------------------------------

# interactively selects installation target and assigns to var DRIVE

selectInstallTarget DRIVE
notifySection "Installation to $DRIVE beginning..."

:<< \
-----------------------------------------------------------------------
READ & PARSE STORAGE TABLE
-----------------------------------------------------------------------

# location of storage table file, taken from manifest variable
STORAGE_TABLE_FILEPATH="${SCRIPT_PATH}/storage/${CONFIG[STORAGE]}"

# note use of 'e' expansion flag to parse variables like $RAM
STORAGE_TABLE=("${(@ef)$(egrep -v "^#|^$" "${STORAGE_TABLE_FILEPATH}")}")

extractFieldNames   STORAGE_TABLE STORAGE_FIELD_NAMES
extractFieldValues  STORAGE_TABLE STORAGE_FIELD_VALUES
parseTableToRecords STORAGE_FIELD_VALUES \
                    STORAGE_FIELD_NAMES \
                    NUM_STORAGE_RECORDS \
                    STORAGE_RECORDS

# If parseTableToRecords found a mismatch in the table formatting
# then it throws an error. Handle it here.
if (( $? > 0 )); then
    print "\n\nERROR: Failed to parse storage table; check table format."
    exit
fi

# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
MOUNT_POINTS=(${(vo)STORAGE_RECORDS[(I)*,MOUNT_POINT]})

:<< \
-----------------------------------------------------------------------
PROCESS STORAGE TABLE DATA
-----------------------------------------------------------------------

# Assemble install paths
# Assign the parent device/storage container path to it's children
# The table is positionally semantic, i.e. order matters though
# only for the assignment of /dev/sdx# partition numbers
_partition_index=0
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if (( ${_record_parent_index:-0} == 0 ));
    then # no parent, so partition path will be something like /dev/sdx1
        (( _partition_index += 1 ))
        STORAGE_RECORDS[${_record_index},DEVICE_INDEX]=$_partition_index
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=${DRIVE}$_partition_index
    elif [[ ${(L)_record_parent_fstype} == "luks" ]];
    then # luks child, so /dev/mapper/parentlabel path
        _mapped_device_path=/dev/mapper/$_record_parent_label
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_mapped_device_path
    elif [[ ${(L)_record_parent_fstype} == "btrfs" ]];
    then # btrfs subvolume (children must always follow parents in table for
         # this to work unless I change the logic of this loop)
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_record_parent_device_path
        STORAGE_RECORDS[${_record_index},BTRFS,SUBVOLUME]=true
    else
        print "\n\nERROR: Unknown parent/child relationship found."
        print "Storage table entry #${_record_index}, label: ($_record_label)"
        print "Child FSTYPE:  $_record_fstype"
        print "Parent FSTYPE: $_record_parent_fstype"
        print "\nExiting.\n"
        exit 1
    fi
    unsetActiveStorageRecordWithPrefix _record
done

:<< \
'-----------------------------------------------------------------------'
DISK PREPARATION - DESTRUCTIVE
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
DEBUG for second pass
-----------------------------------------------------------------------
# DEBUGGING - turn off active swap
swapoff -a

# DEBUGGING close any open crypt devices 
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} == luks ]]; then
        cryptsetup close $_record_label &>/dev/null || :
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Erase drive, create new GPT structure, and create partitions
storageGeneratePartitioningCommandForDrive _part_command $DRIVE
eval "$_part_command"

:<< \
'-----------------------------------------------------------------------'
ENCRYPT STORAGE
-----------------------------------------------------------------------

# Check if we need encryption
ENCRYPTION=false
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    [[ ${(L)_record_fstype} == luks ]] && ENCRYPTION=true || :
    unsetActiveStorageRecordWithPrefix _record
done

if [[ $ENCRYPTION == true ]]; then

    # Get passphrase
    setPassphrase PASSPHRASE "disk encryption passphrase"
    #PASSPHRASE=DEBUG

    # Encrypt partitions
    for _record_index in {1..$NUM_STORAGE_RECORDS}; do
        setActiveStorageRecordWithPrefix $_record_index _record
        if [[ ${(L)_record_fstype} == luks ]]; then
        print "Encrypting $_record_label on $_record_device_path ... "
            print -r "$PASSPHRASE" \
                | cryptsetup ${LUKS_OPTIONS[FORMAT_OPTIONS]:-} \
                  luksFormat $_record_device_path
            print -r "$PASSPHRASE" \
                | cryptsetup open ${LUKS_OPTIONS[OPEN_OPTIONS]:-} \
                  ${SSD:-${LUKS_OPTIONS[OPEN_OPTIONS,SSD]:-}} \
                  $_record_device_path $_record_label
        fi
        unsetActiveStorageRecordWithPrefix _record
    done

    # Cleanup
    unset PASSPHRASE

fi

:<< \
'-----------------------------------------------------------------------'
MAKE FILESYSTEMS
-----------------------------------------------------------------------

# FIRST PASS: isn't luks, doesn't have "child of"
# (so should be our top level physical partitions)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks && -z ${_record_child_of:-} ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# SECOND PASS: isn't luks itself but is "child of" luks
# (filesystems installed on luks)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && ${(L)_record_parent_fstype:-} == luks ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled ${_record_device_path}
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do
print "\n------------------\nMOUNT POINT $_mount_point"

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

print "record MOUNT POINT $_record_mount_point"

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNT_OPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done

:<< \
-----------------------------------------------------------------------
INSTALL BASE SYSTEM
-----------------------------------------------------------------------
pacstrap $MOUNT_ROOT base #base-devel
genfstab -L $MOUNT_ROOT > $MOUNT_ROOT/etc/fstab
refind-install --root $MOUNT_ROOT
mv $MOUNT_ROOT/boot/EFI/refind $MOUNT_ROOT/boot/EFI/BOOT
mv $MOUNT_ROOT/boot/EFI/BOOT/refind_x86.efi $MOUNT_ROOT/boot/EFI/BOOT/bootx86.efi

:<< \
'-----------------------------------------------------------------------'
CREATE CHROOT SCRIPT; CHROOT, COMPLETION, CLEANUP
-----------------------------------------------------------------------
# extract everything after this section with necessary variables prefixed

# initialize new script
CHROOT_SCRIPT_NAME=atypical-chroot
CHROOT_SCRIPT_PATH="$MOUNT_ROOT/$CHROOT_SCRIPT_NAME"
echo "#!/usr/bin/zsh" >> "$CHROOT_SCRIPT_PATH"

# dump required variables and arrays into new script
function {
for _param
do
    typeset -p $_param >> "$CHROOT_SCRIPT_PATH"
done
} INSTALL CONFIG MKFS_OPTIONS MOUNT_OPTIONS LUKS_OPTIONS STORAGE_RECORDS

# dump functions into script
cat ${SCRIPT_PATH}/scripts/functions >> "$CHROOT_SCRIPT_PATH"

# dump remainder of file into chroot script
sed -n "/>\{10\}/,$ p" "$SCRIPT_PATH" >> "$CHROOT_SCRIPT_PATH"
chmod +x "$CHROOT_SCRIPT_PATH"

#DEBUG
print "CHECK CHROOT SCRIPT"
exit

# chroot
arch-chroot $MOUNT_ROOT "$CHROOT_SCRIPT_NAME"

# post chroot cleanup
rm $MOUNT_ROOT/$CHROOT_SCRIPT_NAME
umount -R $MOUNT_ROOT/boot; umount -R $MOUNT_ROOT; cryptsetup close crypt
echo "check mkinitcpio.conf, efi boot params, etc. and then reboot"; exit
#reboot

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>> CHROOT TRIM LINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

:<< \
'-----------------------------------------------------------------------'
INSTALL OTHER BASIC SYSTEM-RELATED PACKAGES
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
SYSTEM CONFIG - LOCALE, TIME, HOSTNAME
-----------------------------------------------------------------------
export LANG=${CONFIG[LOCALE-CONF]}
print "${CONFIG[LOCALE-GEN]}" >> /etc/locale.gen; locale-gen
print "${CONFIG[LOCALE-CONF]}" > /etc/locale.conf
print "FONT=${CONFIG[CONSOLEFONT]}" >> /etc/vconsole.conf
ln -s /usr/share/zoneinfo/${CONFIG[TIMEZONE]} /etc/localtime
hwclock --systohc --utc
print "${CONFIG[HOSTNAME]}" > /etc/hostname

:<< \
'-----------------------------------------------------------------------'
CLI
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
GUI
-----------------------------------------------------------------------
INSTALL ${PACKAGES[VIDEO]:-}
INSTALL ${PACKAGES[GUI]:-}
enableServices ${SERVICES[GUI]:-}

:<< \
'-----------------------------------------------------------------------'
INITRAMFS
-----------------------------------------------------------------------
# configure initramfs
FILE=/etc/mkinitcpio.conf

KEY=MODULES; VALUE="\"${CONFIG[INIT_MODULES]}\""
sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

# replace base and udev with systemd... confirm no sideffects?
#KEY=HOOKS; VALUE='"base udev autodetect modconf console keyboard block encrypt filesystems"'
#sed -i "s/\($KEY *= *\).*/\1$VALUE/" $FILE

mkinitcpio -p linux

:<< \
'-----------------------------------------------------------------------'
BOOTLOADER
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
PASSWORDS, NEW USER SETUP
-----------------------------------------------------------------------

# root password
#passwd

# new user (only reason we needed to mount the new encrypted /home earlier)
useradd -m -g users -G wheel -s /bin/bash ${CONFIG[USERNAME]}

# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!
#passwd es

# allow wheel
#visudo
cp /etc/sudoers.d /var/tmp/sudoers.new
echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /var/tmp/sudoers.wheel
visudo -cf /var/tmp/sudoers.wheel && mv /var/tmp/sudoers.wheel /etc/sudoers.d/wheel || echo "ERROR updating sudoers; no change made"

:<< \
'-----------------------------------------------------------------------'
POST USER LOGIN INSTALLS
-----------------------------------------------------------------------

:<< \
'-----------------------------------------------------------------------'
EXIT CHROOT FOR CLEANUP
-----------------------------------------------------------------------
exit

