:<< \
-------------------------------------------------------------------------------
Logging functions
-------------------------------------------------------------------------------
# Set up log file and fd. This is a standard format used throughout atypical
# and thus we check to see if LOGFD has already been defined, skipping if so.
# This allows autoload function scripts to also act as stand alone scripts with
# their own independent logging if called directly from the command line.
(( LOGFD )) || { rm -f "${LOGFILE:=/tmp/${SCRIPT_NAME}.log}"; } always
               { integer LOGFD; exec {LOGFD} >> "${LOGFILE}"; }

# teeLog: tee like logging. Examples:
#     teeLog "message"
#     teeLog -w "wrapped message"
#     print "message" | teeLog
#     teeLog <<< "message" 
#     teeLog -w <<EOF
#     "wrapped message" 
#     EOF
defined () { functions $1 &>/dev/null; }
defined teeLog || {
teeLog () { [[ "${1:-}" == "-w" ]] && w="${(r:80::--:):-}" && shift || w=""
    m=("${@:-$(while read line; do print $line; done)}");
    print -- "${w:-}${w:+\n}${(@F)m:-}${w:+\n}${w:-}" >&1 >&$LOGFD;} }
defined progressLog || {
    progressLog () { print $( ${DEBUG:-false} \
                     || print -- "-n") -- "${@:-}..." >&1 >&$LOGFD; } }
defined printLog || { printLog () { print -- "${@:-}" >&1 >&$LOGFD; } }
defined errorPrint || { errorPrint () { print -P -- "%F{red}${@:-}%f"; } }
defined errorlog || { errorLog () { errorPrint "$@" >&1 >&$LOGFD 2>&$LOGFD; return 1; } }
defined errorlog || { errorLog () { errorPrint "$@" >&1 >&$LOGFD; return 1; } }
defined successPrint || { successPrint () { print -P -- "%F{green}${@:-}%f"; } }
defined successlog || { successLog () { successPrint "$@" >&1 >&$LOGFD; } }
defined debugLog || {
    if ${DEBUG:-false}; then
        debugLog () { print -- "${@:-}" >&1 >&$LOGFD; }
    else
        debugLog () { print -- "${@:-}" >&$LOGFD; }
    fi
    }

# semantic comments:
# Without these aliases, the semantic comment style is ignored silently
# as "just a comment". With these aliases, the semantic comment content
# is output to the console and logged.
alias -g  :\'\'='cat >&1 >$LOGFD'
alias -g  :\"\"='print -P -- "%B\n${__:=${(r:80::--:):-}}" >&1 >&$LOGFD;
                { cat; print -P -- "$__%b"; } >&1 >&$LOGFD'

# ioLog - different based on debug. unlike above logging functions, error
# state will be preserved by using ioLog.
#
# usage:
#
# { print "no error"; generateerror; } ioLog
#
# The above braces enclosed list will pass the final error state through
# ioLog so that it can be trapped or handled afterwards.
[[ -z ${DEBUG:-} ]] \
        && alias ioLog='>&1 >&$LOGFD 2>&$LOGFD' \
        || alias ioLog='>&1 >&$LOGFD 2>&1'
