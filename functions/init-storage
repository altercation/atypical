#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 
:<< \
-------------------------------------------------------------------------------
Script environment
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
# here
(( ${+SCRIPT_ROOT} )) || {
    SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done
    }

:<< \
-------------------------------------------------------------------------------
Initialize variables and check arguments
-------------------------------------------------------------------------------
# initial declarations
# typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

[[ -n "${MOUNTROOT:-}" ]] \
    && MOUNTROOT="${MOUNTROOT:-}" || MOUNTROOT="${2:-/mnt}"

RAM=$(print "$(( $(print ${$(cat /proc/meminfo \
    | grep -i memtotal)[2]}) / 1000000 ))G")

# fail if missing storage table filename/path argyment
[[ -n ${STORAGE_FILE:=${1:-}} ]] \
    || { errorLog "No storage table file specified." || usage 1; }

TMPSTOR="$TMPDIR/storage"
[[ -f "$TMPSTOR" ]] \
    && errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!"

:<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

typeset -A STOROPTS STORCMD

STORCMD[BTRFS]=''
STORCMD[BTRFS]=''
STORCMD[VFAT]=''
STORCMD[VFAT,SSD]=''
STORCMD[EXFAT]=''
STORCMD[EXT2]=''
STORCMD[EXT3]=''
STORCMD[EXT4]=''
STORCMD[F2FS]=''
STORCMD[JFS]=''
STORCMD[NILFS2]=''
STORCMD[NTFS]=''
STORCMD[REISER4]=''
STORCMD[REISERFS]=''
STORCMD[XFS]=''
STORCMD[ZFS]=''

STOROPTS[MKFS,COMMON]=''
STOROPTS[MKFS,SSD]=''
STOROPTS[MKFS,BTRFS]='--force --label $_record_label'
STOROPTS[MKFS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
STOROPTS[MKFS,VFAT]='-F32 -n $_record_label'
STOROPTS[MKFS,VFAT,SSD]=''
STOROPTS[MKFS,EXFAT]=''
STOROPTS[MKFS,EXT2]=''
STOROPTS[MKFS,EXT3]=''
STOROPTS[MKFS,EXT4]=''
STOROPTS[MKFS,F2FS]=''
STOROPTS[MKFS,JFS]=''
STOROPTS[MKFS,NILFS2]=''
STOROPTS[MKFS,NTFS]=''
STOROPTS[MKFS,REISER4]=''
STOROPTS[MKFS,REISERFS]=''
STOROPTS[MKFS,XFS]=''
STOROPTS[MKFS,ZFS]=''

STOROPTS[MOUNT,COMMON]='rw'
STOROPTS[MOUNT,SSD]='noatime'
STOROPTS[MOUNT,BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
STOROPTS[MOUNT,BTRFS,SSD]='ssd,discard_space'
STOROPTS[MOUNT,VFAT]='-F32 -n $_record_label'
STOROPTS[MOUNT,VFAT,SSD]=''
STOROPTS[MOUNT,EXFAT]=''
STOROPTS[MOUNT,EXT2]=''
STOROPTS[MOUNT,EXT3]=''
STOROPTS[MOUNT,EXT4]=''
STOROPTS[MOUNT,F2FS]=''
STOROPTS[MOUNT,JFS]=''
STOROPTS[MOUNT,NILFS2]=''
STOROPTS[MOUNT,NTFS]=''
STOROPTS[MOUNT,REISER4]=''
STOROPTS[MOUNT,REISERFS]=''
STOROPTS[MOUNT,XFS]=''
STOROPTS[MOUNT,ZFS]=''

# Note that --force-password allows weak passphrases (for testing only)
STOROPTS[LUKS,FORMAT]='--force-password'
STOROPTS[LUKS,OPEN]=''
STOROPTS[LUKS,OPEN,SSD]='--allow-discards'

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical storage table file
-------------------------------------------------------------------------------
# source remote URI or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]; then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]; then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
                 "\nCheck your storage subdirectory and naming." \
                 "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]; then
    errorLog "Could not find storage table file at path $STORAGE_FILE."
fi


:""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------

# note use of 'e' expansion flag to parse variables like $RAM

zmodload zsh/zutil

unset STORAGE; typeset -A STORAGE

# only these storage types allowed
valueIsInList () {
    typeset -A _opts
    zmodload zsh/zutil
    zparseopts -D -E -A _opts -value: -list:
    _value="${${_opts[--value]:-}#=}"
    _list=(${(ps: :)${_opts[--list]:-}})
    (( ${_list[(i)$_value]} <= ${#_list} ))
    }

typeIsValidStorageType () {
    typeset _type="$1"
    typeset -A VALID
    VALID=(TYPES "drive partition logical encryption filesystem subvolume swap")
    valueIsInList --value $_type --list "${VALID[TYPES]}" && return 0 || \
        errorLog "$_type is not a valid storage type."
    }

typeIsValidChildOf () {
    typeset _type="$1" _parent_type=$2
    typeset -A VALID
    VALID=(
        TYPES,CHILDREN,DRIVE "partition logical encryption filesystem"
        TYPES,CHILDREN,PARTITION "logical encryption filesystem swap"
        TYPES,CHILDREN,ENCRYPTION "logical filesystem swap"
        TYPES,CHILDREN,FILESYSTEM "subvolume"
        TYPES,CHILDREN,SWAP ""
        )
        valueIsInList --value $_type \
            --list "${VALID[TYPES,CHILDREN,${(U)_parent_type}]}" || \
            errorLog "$_type is not a valid child type for $_parent_type."
    }

_convert_storage_file_to_array () {
    # _opts contains the arguments passed to this function

    typeset -A _opts
    zmodload zsh/zutil
    zparseopts -D -E -A _opts -input: -output:
    _inputfilepath="${${_opts[--input]:-}#=}"
    _outputarrayname="${${_opts[--output]:-}#=}"

    # initialization
    [[ -n "$_inputfilepath" && -n "$_outputarrayname" ]] \
        || errorLog "$0 requires both a filepath and output arrayname."

    unset PAYLOAD
    typeset -ag STORAGE_CMDS $_outputarrayname
    typeset -a STORAGE_FILE_RAW_DATA
    typeset -a STORAGE_FILE_SCRUBBED_DATA
    typeset -Ag CHILDREN

    # read storage file into array
    STORAGE_FILE_RAW_DATA=(${(f)"$(<$_inputfilepath)"})

    # strip comments (full or partial)
    # merge escaped newlines into single lines
    for _line in "${(@)STORAGE_FILE_RAW_DATA}"; do

        # if this line isn't blank or a comment, continue to process
        if [[ -n "${_line::=${_line//\#*}}" \
            && ! "$_line" =~ "^[[:space:]]*$" ]]; then

            # if this line ends in an escaped newline, prep to merge with next
            if [[ "${_line[-1]}" == \\ ]]; then
                # set as previous line (and append if we have escaped
                # newlines on multiple sequential lines)
                _prev_line="${_prev_line:-}$_line[1,-2]"

            # otherwise assign line to payload (merging with any prev line)
            else

                _line="${_prev_line:-}$_line"
                _indent="${#${_line}%%[^[:space:]]*}"

                # if this is the first line, initialize the payload and
                # check that the first line is of type drive. if not,
                # prepend a "drive" line (assume implied drive) and add a
                # global indent value
                (( ${+PAYLOAD} )) || {
                    typeset -ag PAYLOAD
                    [[ "${${(ps: :)_line}[1]}" == "drive" ]] && {
                        typeset -i _base_indent=$_indent
                        PAYLOAD=()
                    } || {
                        print "FIRST WORD IS ${${(ps: :)_line}[1]}"
                        typeset -i _extra_indent=1
                        typeset -i _base_indent=0
                        _payload="--type drive "
                        _payload+="--item_indent 0"
                        PAYLOAD=("$_payload")
                        }
                    }

                _payload="--type ${_line:${_indent}:${#_line}} "
                _payload+="--item_indent $(( $_indent + ${_extra_indent:-0} ))"
                PAYLOAD+=("$_payload")
                _prev_line=""
            fi
        fi
    done

    _initialize_storage_tree_values  --base_indent $_base_indent

}

_initialize_storage_tree_values () {
# uses global state PAYLOAD, yuck. should change this to be a passed
# scalar value or at the very least a variable reference. Also, should
# pass the output (STORAGE) array name as a reference, at least. TODO
typeset -i _item_index=0
while (( ${#PAYLOAD} )); do
    _boolopts=(bootable noclobber)
    _funcopts=(base_indent item_indent parent_index section_indent)
    _storopts=(devpath fstype label mountopts mountpoint size type)
    _head="${PAYLOAD[1]:-}"
    eval set -- "$@ $_head"
    for _opt in $_boolopts; do
            eval "zparseopts -E -$_opt=_$_opt"
            eval _$_opt'=true'
    done
    for _opt in $_funcopts $_storopts; do
            eval "zparseopts -E -$_opt:=_$_opt"
            eval _$_opt'[1]=()'
            eval '[[ -z "${_'$_opt'[1]:-}" ]] || \
                _'$_opt'[1]="${_'$_opt'[1]#=}"'
    done

    # item is a peer of the current section
    if (( $_item_indent == ${_section_indent:-$_base_indent} ))
    then
        _item_index+=1
        _parent_index_d="${_parent_index:-}${_parent_index:+,}"
        _full_index="${_parent_index_d}${_item_index}"

        # check that the storage item is not a toaster
        typeIsValidStorageType $_type

        _parent_type="${STORAGE[${_parent_index:-},TYPE]:-}"
        if [[ -n ${_parent_type} ]]; then
            # has a parent, check it
            typeIsValidChildOf $_type $_parent_type
        elif [[ "$_type" != "drive" ]]; then
            # no parent, make sure it is of type drive
            # if not, assume implied drive and insert a
            # plain drive entry above it? TODO
            errorLog "Root devices must be type \"drive\""\
                     "(not \"$_type\")."
        fi

        # STORAGE[${_parent_index_d}CHILDTYPES]+=" $_type"
        STORAGE[${_parent_index_d}CHILDREN]+=" $_full_index"

        # $DEBUG && STORAGE[${_full_index},ARGS]="$@ $_head"

        [[ -z ${_parent_index} ]] || \
            STORAGE[${_full_index},PARENT]+="$_parent_index"

        for _opt in $_storopts; do
            eval '_optvalue="${_'$_opt'}"'
            [[ -z "${_optvalue}" ]] || \
                STORAGE[${_full_index},${(U)_opt}]+="$_optvalue"
        done

        # trim payload for next go round
        PAYLOAD[1]=()

    # item is a child of the current section, so recurse
    elif (( $_item_indent > ${_section_indent:-$_base_indent} ))
    then
        _full_index="${_parent_index:-}${_parent_index:+,}${_item_index}"
        $0  --base_indent "$_base_indent" \
            --section_indent "$_item_indent" \
            --parent_index "$_full_index"

    elif (( $_item_indent < ${_section_indent:-$_base_indent} ))
    then

        # payload head is superior to current level, so return from
        # recursive call until we get back to a peer level
        return 0

    fi
done
}

_convert_storage_file_to_array --input $STORAGE_FILE --output STORAGE_COMMANDS 

# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
MOUNTPOINTS=(${(vo)STORAGE[(I)*,MOUNTPOINT]})

:""<< \
-------------------------------------------------------------------------------
Identifying installation drive(s)
-------------------------------------------------------------------------------
# Uses either the preset --devpath value for drives from the storage file or
# interactively selects the drive

# Create list of drives and remove mounted drives from list
selectDrive () {
varname=$1
typeset -a drives
drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
debugLog "Full list of drives: $drives"

# check if device or child has an existing mountpoint and remove from drives
# array if so
for drive in $drives; do
    { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $drive)" ]] \
      || mount | grep $drive; } && drives=("${(@)drives:#$drive}") || :
done
debugLog "List of drives with no mountpoint: $drives"

userQuit () { printLog "\nUser selected quit."; exit; }

# User selects drive for install
typeset CONFIRM="" SELECTED=""
typeset -i i=0
while [[ ! $CONFIRM =~ [Yy] ]]; do

    # list drives
    printLog "Available unmounted drives for installation:\n"
	for drive in $drives; do
        alertLog "[$(( i += 1))] $drive ($(/usr/bin/lsblk -dno SIZE $drive))"
    done

    # Pick drive or quit
	queryLog "\nPlease enter the number of the drive you wish to install to," \
             "or 'q' to quit: (1$((($i > 1)) && queryLog "-$i")/q) "
	while [[ -z $SELECTED || ! $SELECTED =~ [1-$i] && ! ${(L)SELECTED} == q ]]
    do
        queryLog "\b \b"
        read -k 1 SELECTED || : # read returns an error code at EOF; ignore it
    done
    [[ $SELECTED != "q" ]] || userQuit

    # Identify as SSD or standard
	queryLog "\n\nIs $drives[$SELECTED] an SSD? (y/N):"
    read -k SSD || :; [[ ${(L)SSD} == y ]] && SSD="" || unset SSD; echo

    # Summarize and confirm
	alertLog "\nYou have selected $drives[$SELECTED] for"\
             "COMPLETE ERASURE, and identified it as ${SSD-NOT }an SSD."
    queryLog "\nEnter'y' to erase, 'n' to make changes, or 'q' to quit: (y/N/q) "
    read -k CONFIRM ||:; [[ ${(L)CONFIRM} != "q" ]] || userQuit
done

eval "typeset -g $varname"
eval $varname'=$drives[$SELECTED]'
}

_drives=(${(ps: :)STORAGE[CHILDREN]})
for _drive in ${_drives}; do
    debugLog "Checking drive $_drive"
    if [[ -z "${STORAGE[$_drive,DEVPATH]:-}" ]]; then
        _msg="Please select a drive for installation"
        alertLog "\n\n$_msg"
        if (( ${#_drives} > 1 )); then
            printLog "(drive $_drive of ${#_drives})\n"
        else
            printLog "(single drive installation)\n"
        fi
        selectDrive DRIVEPATH
        STORAGE[$_drive,DEVPATH]="${DRIVEPATH:-}"
    else
        # set a flag so that we know a drive device path has been picked using
        # a value from the storage file... we want to confirm again if this is
        # the case...
        STORAGE[FILEPICKEDPATH]=true
    fi
done

# if any of the drive paths were set directly from the storage file, confirm
# before proceeding (no auto erasure)
if (( ${+STORAGE[FILEPICKEDPATH]} )); then
        (( ${#_drives} > 1 )) && s="s" || s=""
        alertLog "\nIMPORTANT - DATA WILL BE ERASED!"
        printLog "Installation will occur to the following device$s:\n"
        for _drive in ${_drives}; do
            printLog "DRIVE $_drive device path: ${STORAGE[$_drive,DEVPATH]}"
        done
        queryLog "Enter'y' to install to drive$s listed above or 'q' to quit: (y/q) "
        read -k CONFIRM ||:; [[ ${(L)CONFIRM} == "y" ]] || userQuit
fi

alertLog "\n\nInstallation beginning..."

:""<< \
-------------------------------------------------------------------------------
Assembling device paths on target drive(s)
-------------------------------------------------------------------------------
makeDevPaths () {

typeset _parent_index="${1:-}"
typeset _parent_index_d="${_parent_index:-}${_parent_index:+,}"
typeset _full_index

for _full_index in ${(ps: :)STORAGE[${_parent_index_d}CHILDREN]:-}; do

    typeset _item_type=${STORAGE[${_full_index},TYPE]}
    typeset _parent_devpath=${STORAGE[${_parent_index_d}DEVPATH]:-}
    typeset _devpath=${STORAGE[${_full_index},DEVPATH]:-}
    typeset _item_label=${STORAGE[${_full_index},LABEL]:-}

    # if it hasn't already been set
    if [[ -z "$_devpath" ]]; then

        # partitions
        if [[ "$_item_type" == "partition" ]]; then
            _devpath=${_parent_devpath}${_full_index##*,}

        # encryption
        elif [[ "$_item_type" == "encryption" ]]; then
            _devpath=/dev/mapper/
            [[ -n ${STORAGE[${_full_index},LABEL]:-} ]] \
                && _devpath+=${STORAGE[${_full_index},LABEL]:-// /_} \
                || _devpath+=${STORAGE[${_parent_index},DEVPATH]//\//_}

        # swap
        elif [[ "$_item_type" == "swap" ]]; then
            _devpath=$_parent_devpath

        # filesystem
        elif [[ "$_item_type" == "filesystem" ]]; then
            _devpath=$_parent_devpath

        # filesystem
        elif [[ "$_item_type" == "subvolume" ]]; then
            _devpath=$_parent_devpath

        fi
        STORAGE[${_full_index},DEVPATH]=${_devpath}

    fi

    # recursively handle children
    makeDevPaths ${_full_index}

done
}

makeDevPaths

debugLog "\nSTORAGE ARRAY VALUES:\n"
for _childkey in ${(ovps: :)STORAGE[(I)*CHILDREN]}; do
    for _key in ${(ok)STORAGE[(I)$_childkey,[^[:digit:]]*]}; do
        debugLog "$_key: ${STORAGE[$_key]}"
    done
done
#debugLog "\n\nOrder of initialization:"
#debugLog ${STORAGE[CHILDREN]}
#debugLog ${(ov)STORAGE[(I)*CHILDREN]}

exit

:<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS
-------------------------------------------------------------------------------

:<< \
-------------------------------------------------------------------------------
DEBUG for second pass
# DEBUGGING - turn off active swap
swapoff -a

# DEBUGGING close any open crypt devices 
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} == luks ]]; then
        cryptsetup close $_record_label &>/dev/null || :
    fi
    unsetActiveStorageRecordWithPrefix _record
done
-------------------------------------------------------------------------------

# Erase drive, create new GPT structure, and create partitions
storageGeneratePartitioningCommandForDrive _part_command $DRIVE
eval "$_part_command"

:<< \
-------------------------------------------------------------------------------
ENCRYPT STORAGE
-------------------------------------------------------------------------------

# Check if we need encryption
ENCRYPTION=false
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    [[ ${(L)_record_fstype} == luks ]] && ENCRYPTION=true || :
    unsetActiveStorageRecordWithPrefix _record
done

if [[ $ENCRYPTION == true ]]; then

    # Get passphrase
    setPassphrase PASSPHRASE "disk encryption passphrase"
    #PASSPHRASE=DEBUG

    # Encrypt partitions
    for _record_index in {1..$NUM_STORAGE_RECORDS}; do
        setActiveStorageRecordWithPrefix $_record_index _record
        if [[ ${(L)_record_fstype} == luks ]]; then
        print "Encrypting $_record_label on $_record_device_path ... "
            print -r "$PASSPHRASE" \
                | cryptsetup ${LUKS_OPTIONS[FORMAT_OPTIONS]:-} \
                  luksFormat $_record_device_path
            print -r "$PASSPHRASE" \
                | cryptsetup open ${LUKS_OPTIONS[OPEN_OPTIONS]:-} \
                  ${SSD:-${LUKS_OPTIONS[OPEN_OPTIONS,SSD]:-}} \
                  $_record_device_path $_record_label
        fi
        unsetActiveStorageRecordWithPrefix _record
    done

    # Cleanup
    unset PASSPHRASE

fi

:<< \
-------------------------------------------------------------------------------
MAKE FILESYSTEMS
-------------------------------------------------------------------------------

# FIRST PASS: isn't luks, doesn't have "child of"
# (so should be our top level physical partitions)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks && -z ${_record_child_of:-} ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# SECOND PASS: isn't luks itself but is "child of" luks
# (filesystems installed on luks)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && ${(L)_record_parent_fstype:-} == luks ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled ${_record_device_path}
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNT_OPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done

# vim: set filetype=sh :
