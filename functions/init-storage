#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 
:<< \
-------------------------------------------------------------------------------
Script environment
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
# here
(( ${+SCRIPT_ROOT} )) || {
    SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done
    }

:<< \
-------------------------------------------------------------------------------
Initialize variables and check arguments
-------------------------------------------------------------------------------
# initial declarations
# typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

[[ -n "${MOUNTROOT:-}" ]] \
    && MOUNTROOT="${MOUNTROOT:-}" || MOUNTROOT="${2:-/mnt}"

RAM=$(print "$(( $(print ${$(cat /proc/meminfo \
    | grep -i memtotal)[2]}) / 1000000 ))G")

# fail if missing storage table filename/path argyment
[[ -n ${STORAGE_FILE:=${1:-}} ]] \
    || { errorLog "No storage table file specified." || usage 1; }

TMPSTOR="$TMPDIR/storage"
[[ -f "$TMPSTOR" ]] \
    && errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!"

:<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

typeset -A STOROPTS STORCMD

STORCMD[BTRFS]=''
STORCMD[BTRFS]=''
STORCMD[VFAT]=''
STORCMD[VFAT,SSD]=''
STORCMD[EXFAT]=''
STORCMD[EXT2]=''
STORCMD[EXT3]=''
STORCMD[EXT4]=''
STORCMD[F2FS]=''
STORCMD[JFS]=''
STORCMD[NILFS2]=''
STORCMD[NTFS]=''
STORCMD[REISER4]=''
STORCMD[REISERFS]=''
STORCMD[XFS]=''
STORCMD[ZFS]=''

STOROPTS[MKFS,COMMON]=''
STOROPTS[MKFS,SSD]=''
STOROPTS[MKFS,BTRFS]='--force --label $_record_label'
STOROPTS[MKFS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
STOROPTS[MKFS,VFAT]='-F32 -n $_record_label'
STOROPTS[MKFS,VFAT,SSD]=''
STOROPTS[MKFS,EXFAT]=''
STOROPTS[MKFS,EXT2]=''
STOROPTS[MKFS,EXT3]=''
STOROPTS[MKFS,EXT4]=''
STOROPTS[MKFS,F2FS]=''
STOROPTS[MKFS,JFS]=''
STOROPTS[MKFS,NILFS2]=''
STOROPTS[MKFS,NTFS]=''
STOROPTS[MKFS,REISER4]=''
STOROPTS[MKFS,REISERFS]=''
STOROPTS[MKFS,XFS]=''
STOROPTS[MKFS,ZFS]=''

STOROPTS[MOUNT,COMMON]='rw'
STOROPTS[MOUNT,SSD]='noatime'
STOROPTS[MOUNT,BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
STOROPTS[MOUNT,BTRFS,SSD]='ssd,discard_space'
STOROPTS[MOUNT,VFAT]='-F32 -n $_record_label'
STOROPTS[MOUNT,VFAT,SSD]=''
STOROPTS[MOUNT,EXFAT]=''
STOROPTS[MOUNT,EXT2]=''
STOROPTS[MOUNT,EXT3]=''
STOROPTS[MOUNT,EXT4]=''
STOROPTS[MOUNT,F2FS]=''
STOROPTS[MOUNT,JFS]=''
STOROPTS[MOUNT,NILFS2]=''
STOROPTS[MOUNT,NTFS]=''
STOROPTS[MOUNT,REISER4]=''
STOROPTS[MOUNT,REISERFS]=''
STOROPTS[MOUNT,XFS]=''
STOROPTS[MOUNT,ZFS]=''

# Note that --force-password allows weak passphrases (for testing only)
STOROPTS[LUKS,FORMAT]='--force-password'
STOROPTS[LUKS,OPEN]=''
STOROPTS[LUKS,OPEN,SSD]='--allow-discards'

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical storage table file
-------------------------------------------------------------------------------
# source remote or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]; then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]; then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
                 "\nCheck your storage subdirectory and naming." \
                 "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]; then
    errorLog "Could not find storage table file at path $STORAGE_FILE."
fi

# read storage file into array, stripping comments and merging escaped
# newlines into single lines
STORAGE_FILE_DATA=(${(f)"$(<$STORAGE_FILE)"})
for _line in "${(@)STORAGE_FILE_DATA}";
do
    # trim comments, skip blank lines
    if [[ -n ${_line::=${_line//\#*}} && ! "$_line" =~ "^[[:space:]]*$" ]];
    then
        if [[ "${_line[-1]}" == \\ ]]; then
            _prev_line="$_line[1,-2]"
        else
            STORAGE_DATA=(${(@)STORAGE_DATA:-} "${_prev_line:-}$_line")
            prev_line=""
        fi
    fi
done

:""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------

# note use of 'e' expansion flag to parse variables like $RAM

zmodload zsh/zutil
unset STORAGE; typeset -A STORAGE
BOOLEAN_OPT_ARRAYS=(
    BOOTABLE
    NOCLOBBER
    )
SCALAR_OPT_ARRAYS=(
    CODE
    DEVPATH
    FSTYPE
    LABEL
    MOUNTPOINT
    MOUNTOPTS
    SIZE
    )
eval "typeset -a $BOOLEAN_OPT_ARRAYS $SCALAR_OPT_ARRAYS"

# this function handles the pseudo commands like:
#     drive
#         partition --label "MyLabel"
#         partition --label "AnotherPartition"
# from the storage stable file
_parse_storage_item () {

    # increment index
    typeset -g ITEMINDEX=+1

    # make sure storage is set
    typeset -gA STORAGE

    # handle variations on allowed options
    zmodload zsh/zutil
    zparseopts -D -E \
    b::-=BOOTABLE -boot::-=BOOTABLE -bootable::-=BOOTABLE \
    n::-=NOCLOBBER -noclobber::-=NOCLOBBER \
    c:=CODE -code:=CODE \
    d:=DEVPATH p:=DEVPATH -path:=DEVPATH \
        -device:=DEVPATH -devpath:=DEVPATH \
    f:=FSTYPE -fs:=FSTYPE -fstype:=FSTYPE -filesystem:=FSTYPE \
    i:=INDEX -id:=INDEX -idx:=INDEX -index:=INDEX \
    l:=LABEL -label:=LABEL \
    m:=MOUNTPOINT -mount:=MOUNTPOINT -mountpoint:=MOUNTPOINT \
    -null=NULL \
    o:=MOUNTOPTS -options:=MOUNTOPTS \
        -mountopts:=MOUNTOPTS -mountoptions:=MOUNTOPTS \
    s:=SIZE -size:=SIZE \
    -sub:=SUBSCRIPT -subscript:=SUBSCRIPT \
    t:=TYPE -type:=TYPE

    typeset _subscript
    _subscript="${SUBSCRIPT[2]:-}${SUBSCRIPT[2]:+,}"
    _subscript="${(U)_subscript}${(U)TYPE[2]}${INDEX[2]:+_}${INDEX[2]}"

    # assign values to indexed storage item parameters
    # (scalar values)
    for _optname in $SCALAR_OPT_ARRAYS
    do
        if [[ -n "${(P)_optname:-}" ]]
        then
            eval _optvalue'="${${'$_optname'[2]:-}#=}"'
            STORAGE[${_subscript},$_optname]="$_optvalue"
        fi
    done

    # assign values to indexed storage item parameters
    # (boolean values)
    for _optname in $BOOLEAN_OPT_ARRAYS
    do
        if [[ -n "${(P)_optname:-}" && ! "${(LP)_optname:-}" =~ ".*false" ]]
        then
            STORAGE[${_subscript},$_optname]=true
        fi
    done

    # create a null entry for testing so we know this item exists
    # (required in case item has no other parameters)
    STORAGE[${_subscript},EXISTS]=true

    if [[ -n "$@" ]]; then
        errorLog "Unknown storage options: $@" \
                 "\nCheck for correct spelling," \
                 "formatting, option dashes, etc."
    fi

    }

# maketree iterates over the storage file data pseudo-commands and is
# responsible for creating the correct array subscript and numbering
# peers (partition 1, drive 2, etc.)
_make_tree () {

    # _opts contains the arguments passed to this function
    # _level is typeset here to make it local to all recursive calls
    # without this typeset, it is local to the function but exports itself
    # to subsequent calls
    # _index is the peer level item index (e.g. drive 1, drive 2)
    typeset -A _opts
    typeset _head _tail _level _subscript _payload _prev_type _prev_index
    typeset -i _index=0

    # get the currently being processed indent level and subscript if being
    # called recursively, or set defaults
    zmodload zsh/zutil
    zparseopts -D -E -A _opts -level: -subscript:
    _level="${${_opts[--level]:-0}#=}"
    _subscript="${${_opts[--subscript]:-}#=}"
    _payload="${${_opts[--payload]:-}#=}"

    # initialize payload (a global common to all recursive calls)
    # parse remaining options in such a way that we handle both incoming
    # multiple line, single argument strings and multiple single line arrays
    (( ${+PAYLOAD} )) || {
        typeset -ag PAYLOAD;
        for _item in $@; do PAYLOAD=(${(@)PAYLOAD:-} ${(f)_item}); done;
        # reset level to initial item in case the entire block of storage
        # items has been indendent for some reason
        _level="${#${${(@)PAYLOAD[1]:-}}%%[^[:space:]]*}"
        }

    while (( ${#PAYLOAD} )); do
        # head and tail the payload
        # (--null is just to make sure we can pull out a single word for
        # the subscript later on... a silly hack, probably a better way
        # using a different zsh expansion)
        _head=(${(@)PAYLOAD[1]:-} --null); _tail=(${(@)PAYLOAD[2,-1]:-})

        # determine the indendation level
        _head_level="${#${_head}%%[^[:space:]]*}"

        if (( $_head_level > $_level )); then
            # payload head is child of the current _level value, so recurse
            _make_tree --level $_head_level \
            --subscript "${_subscript}${_subscript:+,}${_prev_type}_${_index}"

        elif (( $_head_level == $_level )); then
            # Payload head is peer of the current level so we execute it
            # as a pseudo command that processes its options into array
            # (we also strip whitespace from head for cleaner debug
            # output). For example, the initial line of a payload should be
            # "drive ..." and the initial level will be 0, so 
            _index+=1
            eval "_parse_storage_item --type ${(z)_head}" \
                 "--index $_index --subscript \"$_subscript\""
            _prev_type="${${(ps: :)${_head}}[1]}"
            _prev_index="${_index}"
            PAYLOAD=(${(@)_tail})

        elif (( $_head_level < $_level )); then
            # payload head is superior to current level, so return from
            # recursive call until we get back to a peer level
            return 0

        fi
    done

    }

_make_tree $STORAGE_DATA

# print all existing items in storage array
print -l ${(o)${(k)STORAGE[(I)*EXISTS]}%,EXISTS}

exit

:<< \
SECTION
complianceCheck
    each item type has a series of compliance checks
parse all items
    need to check to see hwat the children/parents are of each item


compliance[drive]=(
must have at least one child of type partition or fsype btrfs
if has path set, must prompt for noclobber
if has path set, must exist
)

compliance[part]=(
parent must be drive
)

parsentry () {

}
alias drive="scanEntry"
etc.


scanPeers () {
}

summarizeChildren
SECTION

source $STORAGE_FILE;

print ">>>>>"
print -l "${(kv)STORAGE}"
print ">>>>>"


# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
MOUNT_POINTS=(${(vo)STORAGE_RECORDS[(I)*,MOUNT_POINT]})

:""<< \
-------------------------------------------------------------------------------
Selecting target install drive
-------------------------------------------------------------------------------
# Interactively selects installation target and assigns to var DRIVE

# Create list of drives and remove mounted drives from list
typeset -a drives
drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
debugLog "Full list of drives: $drives"

# check if device or child has an existing mountpoint and remove from drives
# array if so
for drive in $drives; do
    { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $drive)" ]] \
      || mount | grep $drive; } && drives=("${(@)drives:#$drive}") || :
done
debugLog "List of drives with no mountpoint: $drives"

# User selects drive for install
userQuit () { printLog "\nUser selected quit."; exit; }
local CONFIRM="" SELECTED="" i=0
while [[ ! $CONFIRM =~ [Yy] ]]; do

    # list drives
    printLog "Available unmounted drives for installation:\n"
	for drive in $drives; do
        alertLog "[$(( i += 1))] $drive ($(/usr/bin/lsblk -dno SIZE $drive))"
    done

    # Pick drive or quit
	queryLog "\nPlease enter the number of the drive you wish to install to," \
             "or 'q' to quit: (1$((($i > 1)) && queryLog "-$i")/q) "
	while [[ -z $SELECTED || ! $SELECTED =~ [1-$i] && ! ${(L)SELECTED} == q ]]
    do
        queryLog "\b \b"
        read -k 1 SELECTED || : # read returns an error code at EOF; ignore it
    done
    [[ $SELECTED != "q" ]] || userQuit

    # Identify as SSD or standard
	queryLog "\nIs $drives[$SELECTED] an SSD? (y/N):"
    read -k SSD || :; [[ ${(L)SSD} == y ]] && SSD="" || unset SSD; echo

    # Summarize and confirm
	alertLog "\n\nYou have selected $drives[$SELECTED] for"\
             "COMPLETE ERASURE, and identified it as ${SSD-NOT }an SSD."
    queryLog "Enter'y' to erase, 'n' to make changes, or 'q' to quit: (y/N/q) "
    read -k CONFIRM ||:; [[ ${(L)CONFIRM} != "q" ]] || userQuit
done

DRIVE=$drives[$SELECTED]

alertLog "Installation to $DRIVE beginning..."

exit

:""<< \
-------------------------------------------------------------------------------
Assembling installation paths on target drive
-------------------------------------------------------------------------------
# Assign the parent device/storage container path to it's children
# The table is positionally semantic, i.e. order matters though
# only for the assignment of /dev/sdx# partition numbers
_partition_index=0
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if (( ${_record_parent_index:-0} == 0 ));
    then # no parent, so partition path will be something like /dev/sdx1
        (( _partition_index += 1 ))
        STORAGE_RECORDS[${_record_index},DEVICE_INDEX]=$_partition_index
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=${DRIVE}$_partition_index
    elif [[ ${(L)_record_parent_fstype} == "luks" ]];
    then # luks child, so /dev/mapper/parentlabel path
        _mapped_device_path=/dev/mapper/$_record_parent_label
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_mapped_device_path
    elif [[ ${(L)_record_parent_fstype} == "btrfs" ]];
    then # btrfs subvolume (children must always follow parents in table for
         # this to work unless I change the logic of this loop)
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_record_parent_device_path
        STORAGE_RECORDS[${_record_index},BTRFS,SUBVOLUME]=true
    else
        print "\n\nERROR: Unknown parent/child relationship found."
        print "Storage table entry #${_record_index}, label: ($_record_label)"
        print "Child FSTYPE:  $_record_fstype"
        print "Parent FSTYPE: $_record_parent_fstype"
        print "\nExiting.\n"
        exit 1
    fi
    unsetActiveStorageRecordWithPrefix _record
done

:<< \
-------------------------------------------------------------------------------
Child/Parent storage functions
-------------------------------------------------------------------------------
phys,erase,luks
phys,erase,btrfs


:<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS
-------------------------------------------------------------------------------

:<< \
-------------------------------------------------------------------------------
DEBUG for second pass
-------------------------------------------------------------------------------
# DEBUGGING - turn off active swap
swapoff -a

# DEBUGGING close any open crypt devices 
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} == luks ]]; then
        cryptsetup close $_record_label &>/dev/null || :
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Erase drive, create new GPT structure, and create partitions
storageGeneratePartitioningCommandForDrive _part_command $DRIVE
eval "$_part_command"

:<< \
-------------------------------------------------------------------------------
ENCRYPT STORAGE
-------------------------------------------------------------------------------

# Check if we need encryption
ENCRYPTION=false
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    [[ ${(L)_record_fstype} == luks ]] && ENCRYPTION=true || :
    unsetActiveStorageRecordWithPrefix _record
done

if [[ $ENCRYPTION == true ]]; then

    # Get passphrase
    setPassphrase PASSPHRASE "disk encryption passphrase"
    #PASSPHRASE=DEBUG

    # Encrypt partitions
    for _record_index in {1..$NUM_STORAGE_RECORDS}; do
        setActiveStorageRecordWithPrefix $_record_index _record
        if [[ ${(L)_record_fstype} == luks ]]; then
        print "Encrypting $_record_label on $_record_device_path ... "
            print -r "$PASSPHRASE" \
                | cryptsetup ${LUKS_OPTIONS[FORMAT_OPTIONS]:-} \
                  luksFormat $_record_device_path
            print -r "$PASSPHRASE" \
                | cryptsetup open ${LUKS_OPTIONS[OPEN_OPTIONS]:-} \
                  ${SSD:-${LUKS_OPTIONS[OPEN_OPTIONS,SSD]:-}} \
                  $_record_device_path $_record_label
        fi
        unsetActiveStorageRecordWithPrefix _record
    done

    # Cleanup
    unset PASSPHRASE

fi

:<< \
-------------------------------------------------------------------------------
MAKE FILESYSTEMS
-------------------------------------------------------------------------------

# FIRST PASS: isn't luks, doesn't have "child of"
# (so should be our top level physical partitions)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks && -z ${_record_child_of:-} ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# SECOND PASS: isn't luks itself but is "child of" luks
# (filesystems installed on luks)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && ${(L)_record_parent_fstype:-} == luks ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled ${_record_device_path}
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNT_OPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done

# vim: set filetype=sh :
