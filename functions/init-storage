#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 
:<< \
-------------------------------------------------------------------------------
Script environment
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
# here
(( ${+SCRIPT_ROOT} )) || {
    SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done
    }

:<< \
-------------------------------------------------------------------------------
Initialize variables and check arguments
-------------------------------------------------------------------------------
# initial declarations
# typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

[[ -n "${MOUNTROOT:-}" ]] \
    && MOUNTROOT="${MOUNTROOT:-}" || MOUNTROOT="${2:-/mnt}"

# set RAM and ram here; partition --size should be set to value "ram" with no
# leading "$", but in case it is, we'll set this here to not fail hard on
# what otherwise is an intuitive use of a variable. for reference, however,
# the storage definition file should use "partition --size ram"
RAM=$(print "$(( $(print ${$(cat /proc/meminfo \
    | grep -i memtotal)[2]}) / 1000000 ))G"); ram=$RAM

# fail if missing storage table filename/path argyment
[[ -n ${STORAGE_FILE:=${1:-}} ]] \
    || { errorLog "No storage table file specified." || usage 1; }

TMPSTOR="$TMPDIR/storage"
[[ -f "$TMPSTOR" ]] \
    && errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!"

:<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

typeset -A VALID

VALID[FSTYPES]="btrfs vfat exfat ext2 ext3 ext4 f2fs jfs nilfs2 ntfs reiser4 reiserfs xfs zfs"

typeset -A MKFS

MKFS[CMD,BTRFS]=''
MKFS[CMD,BTRFS]=''
MKFS[CMD,VFAT]=''
MKFS[CMD,VFAT,SSD]=''
MKFS[CMD,EXFAT]=''
MKFS[CMD,EXT2]=''
MKFS[CMD,EXT3]=''
MKFS[CMD,EXT4]=''
MKFS[CMD,F2FS]=''
MKFS[CMD,JFS]=''
MKFS[CMD,NILFS2]=''
MKFS[CMD,NTFS]=''
MKFS[CMD,REISER4]=''
MKFS[CMD,REISERFS]=''
MKFS[CMD,XFS]=''
MKFS[CMD,ZFS]=''

MKFS[OPTIONS,COMMON]=''
MKFS[OPTIONS,SSD]=''
MKFS[OPTIONS,BTRFS]='--force${ACTIVE[LABEL]:+ --label }${ACTIVE[LABEL]:-}'
MKFS[OPTIONS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
MKFS[OPTIONS,VFAT]='-F32${ACTIVE[LABEL]:+ -n }${ACTIVE[LABEL]:-}'
MKFS[OPTIONS,VFAT,SSD]=''
MKFS[OPTIONS,EXFAT]=''
MKFS[OPTIONS,EXT2]=''
MKFS[OPTIONS,EXT3]=''
MKFS[OPTIONS,EXT4]=''
MKFS[OPTIONS,F2FS]=''
MKFS[OPTIONS,JFS]=''
MKFS[OPTIONS,NILFS2]=''
MKFS[OPTIONS,NTFS]=''
MKFS[OPTIONS,REISER4]=''
MKFS[OPTIONS,REISERFS]=''
MKFS[OPTIONS,XFS]=''
MKFS[OPTIONS,ZFS]=''

typeset -A MOUNTOPTIONS

MOUNTOPTIONS[COMMON]='rw'
MOUNTOPTIONS[SSD]='noatime'
MOUNTOPTIONS[BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
MOUNTOPTIONS[BTRFS,SSD]='ssd,discard_space'
MOUNTOPTIONS[VFAT]='-F32${ACTIVE[LABEL]:+ -n }${ACTIVE[LABEL]:-}'
MOUNTOPTIONS[VFAT,SSD]=''
MOUNTOPTIONS[EXFAT]=''
MOUNTOPTIONS[EXT2]=''
MOUNTOPTIONS[EXT3]=''
MOUNTOPTIONS[EXT4]=''
MOUNTOPTIONS[F2FS]=''
MOUNTOPTIONS[JFS]=''
MOUNTOPTIONS[NILFS2]=''
MOUNTOPTIONS[NTFS]=''
MOUNTOPTIONS[REISER4]=''
MOUNTOPTIONS[REISERFS]=''
MOUNTOPTIONS[XFS]=''
MOUNTOPTIONS[ZFS]=''

typeset -A LUKS

# Note that --force-password allows weak passphrases (for testing only)
LUKS[FORMAT]='--force-password'
LUKS[OPEN]=''
LUKS[OPEN,SSD]='--allow-discards'

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical storage table file
-------------------------------------------------------------------------------
# source remote URI or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]
then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]
then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
            "\nCheck your storage subdirectory and naming." \
            "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]
then
    errorLog "Could not find storage table file at path $STORAGE_FILE."

fi


:""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------

# The valid options (boolean and scalar separate) for storage items.
# Not all options are valid for all types, but this is at least a basic
# sanity check. Used in the convertStorageFileToArray function, listed
# here as this is the one stop location for adding/removing/renaming.
typeset -a STOROPTS_SCAL STOROPTS_BOOL
STOROPTS_BOOL=(bootable noclobber ssd)
STOROPTS_SCAL=(devpath fstype label code mkfsoptions mountoptions mountpoint size type)

# a little too dependent on state, but it's not easy to functionally
# pass associative arrays around so this will write out to the
# global STORAGE array. This could be passed at least as an explicit
# --output argument (i.e. the name of the array) but indirect references
# to associative array values are ridiculous looking in zsh.
typeset -A STORAGE
convertStorageFileToArray --input $STORAGE_FILE \
    && successLog "Storage file successfully converted for processing." \
    || errorLog "Failed to converted storage file for processing." \

# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
#MOUNTPOINTS=(${(vo)STORAGE[(I)*,MOUNTPOINT]})

:""<< \
-------------------------------------------------------------------------------
Identifying installation drive(s)
-------------------------------------------------------------------------------
# Uses either the preset --devpath value for drives from the storage file or
# interactively selects the drive

# If a drive devpath is not set (normally will be unset), prompt for it here

_drives=($(getStorageItemIndexesOfType drive))
_unmounted_drives="$(getUnmountedDrives)"
for _drive in $_drives
do
    debugLog "Checking drive $_drive"
    if [[ -z "${STORAGE[$_drive,DEVPATH]:-}" ]]
    then
        _msg="Please select a drive for installation"
        alertLog "\n\n$_msg"
        if (( ${#_drives} > 1 )); then
            printLog "(drive $_drive of ${#_drives})\n"
        else
            printLog "(single drive installation)\n"
        fi
        selectDrive DRIVEPATH
        STORAGE[$_drive,DEVPATH]="${DRIVEPATH:-}"
        [[ -z "$SSD" ]] || {
        print "YES IS SSD" # debug DEBUG xxx
        STORAGE[$_drive,SSD]="true"
    }
    else
        # set a flag so that we know a drive device path has been picked using
        # a value from the storage file... we want to confirm again if this is
        # the case...
        valueIsInList --value ${STORAGE[$_drive,DEVPATH]} --list "$_unmounted_drives" || {
        $(${TEST:-false} && print "printLog" || print "errorLog") \
                "${STORAGE[$_drive,DEVPATH]} is specified explicitly in storage" \
                "definition file but is currently\nmounted or inaccessible." || exit 1
            }
        STORAGE[FILEPICKEDPATH]=true
    fi
done

# if any of the drive paths were set directly from the storage file, confirm
# before proceeding (no auto erasure)
if (( ${+STORAGE[FILEPICKEDPATH]} ))
then
    (( ${#$(getStorageItemIndexesOfType drive)} > 1 )) && s="s" || s=""
    # (( ${#_drives} > 1 )) && s="s" || s=""
    ${SIM:-false} || alertLog "IMPORTANT - DATA WILL BE ERASED!"
    printLog "Installation will occur to the following device$s:\n"
    for _drive in $(getStorageItemIndexesOfType drive)
    do
        printLog "DRIVE $_drive device path: ${STORAGE[$_drive,DEVPATH]}"
    done
    ${FORCE:-false} || {
        queryLog "\nEnter'y' to install to drive$s listed, 'q' to quit: (y/q) "
        read -k CONFIRM ||:; [[ ${(L)CONFIRM} == "y" ]] || {
        printLog "\n\nUser selected exit.\n"; exit 0 }
        }
fi

:""<< \
-------------------------------------------------------------------------------
Assembling device paths on target drive(s)
-------------------------------------------------------------------------------
# following function assigns valid device paths to all STORAGE items
makeDevPaths \
    && successLog "Assembled device paths successfully." \
    || errorLog "Failed to assemble device paths."

debugLog "\nSTORAGE ARRAY VALUES:\n"
for _childkey in ${(ovps: :)STORAGE[(I)*CHILDREN]}; do
    for _key in ${(ok)STORAGE[(I)$_childkey,[^[:digit:]]*]}; do
        debugLog "$_key: ${STORAGE[$_key]}"
    done
done

#debugLog "\n\nOrder of initialization:"
#debugLog ${STORAGE[CHILDREN]}
#debugLog ${(ov)STORAGE[(I)*CHILDREN]}

:<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS!
If in test mode, close encrypted volumes, shut down swap and unmount
known mounts
-------------------------------------------------------------------------------
${SIM:-false} || :""""<<< "INSTALLATION BEGINNING... DATA WILL BE ERASED!"
if ${TEST:-false}; then
    printLog "\nTEST MODE: Closing known encrypted and swap items"
    _encryption=($(getStorageItemIndexesOfType encryption))
    for _encrypted_item in ${_encryption}; do
        activateRecord $_encrypted_item
        ${SIM:-false} || cryptsetup close ${ACTIVE[LABEL]} || :
    done
    _swap=($(getStorageItemIndexesOfType swap))
    for _swap_item in ${_swap}; do
        activateRecord $_encrypted_item
        if (( ${+ACTIVE[LABEL]} )); then
            ${SIM:-false} || swapoff -L ${ACTIVE[LABEL]}
        else
            typeset _uuid=$(getUUIDForDevpath ${ACTIVE[DEVPATH]})
            ${SIM:-false} || swapoff -U $_uuid
        fi
    done
fi

:""<< \
-------------------------------------------------------------------------------
Erasing/preparing target drive(s)
-------------------------------------------------------------------------------
for _drive in $(getStorageItemIndexesOfType drive); do
    activateRecord $_drive
    if (( ${+ACTIVE[NOCLOBBER]} )); then
        alertLog "\nNoclobber option set on drive $_drive !"
        printLog "\nNoclobber prevents all changes to a drive. This is likely"\
                 "not what you intended. \nnoclobber should be used on "\
                 "existing partitions or filesystems)\n"
        exit 1
    else
        alertLog "\nPreparing to erase drive $_drive... ${_SIM}"
        ${TEST:-false} && _c=0 || _c=5
        ${SIM:-false} || countdownMsg $_c "Erasing drive ${ACTIVE[DEVPATH]}"
        evalSim  sgdisk --zap-all ${ACTIVE[DEVPATH]} # erase everything!
        evalSim  sgdisk --clear ${ACTIVE[DEVPATH]}   # create new gpt structure
        ${SIM:-false} || successLog "Drive ${ACTIVE[DEVPATH]} erased!"
    fi
done

:""<< \
-------------------------------------------------------------------------------
Processing partitions
-------------------------------------------------------------------------------
_partitions=($(getStorageItemIndexesOfType partition))
if [[ -n "${_partitions}" ]];
then

    # check for bootable option or, if single partition, make it bootable
    # TODO: there may be edge cases where making a single partition bootable
    # is not desirable.
    if (( ${#_partitions} > 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        errorLog "At least one partition must have the --bootable option in" \
            "the storage item\ndefinition file"
    elif (( ${#_partitions} == 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        # single partition, set as bootable
        STORAGE[${_partitions},BOOTABLE]=true
    fi

    typeset -a _sgdisk_cmd
    for _drive in $(getStorageItemIndexesOfType drive); do
        activateRecord $_drive
        _drive_devpath=${ACTIVE[DEVPATH]}
        for _partition in \
            $(getStorageItemIndexesOfTypeForParent partition $_drive)
        do
            activateRecord $_partition
            printLog "Preparing formatting command for ${ACTIVE[DEVPATH]}"
            _id=${ACTIVE[DEVPATH][-1]}
            if [[ ${(L)ACTIVE[SIZE]} =~ "^max" ]]; then
                _sgdisk_cmd+=("--largest-new=${_id}")
            elif [[ ${(L)ACTIVE[SIZE]} =~ "ram" ]]; then
                _sgdisk_cmd+=("--new=${_id}:0:+$RAM")
            else
                _sgdisk_cmd+=("--new=${_id}:0:+${ACTIVE[SIZE]}")
            fi
            if [[ -n "${(L)ACTIVE[BOOTABLE]:-}" ]]; then
                _sgdisk_cmd+=("--attributes=${_id}:set:0")
            fi
            #[[ -z "${ACTIVE[CODE]:-}" ]] || \
            #    _sgdisk_cmd+=("--typecode=${_id}:${ACTIVE[CODE]}")
            _sgdisk_cmd+=(${ACTIVE[CODE]:+--typecode=${_id}:${ACTIVE[CODE]}})
            _sgdisk_cmd+=(${ACTIVE[LABEL]:+--change-name=${_id}:${(q-)ACTIVE[LABEL]}})
        done
        _sgdisk_cmd+=($_drive_devpath)
        evalSim "print 'Partitioning...' && sgdisk $_sgdisk_cmd && print 'Partitions created successfully' || { print 'Partition creation failed'; exit 1; }"
    done
else
    # TODO: can add in an fstype validity check here and remove warning
    alertLog "No partitions listed as children of drives! Ensure you have" \
        "specified a\nfilesystem type that can be initialized directly to a" \
        "drive without a partition.\nPROCEEDING..."
fi

:""<< \
-------------------------------------------------------------------------------
Encrypting storage
-------------------------------------------------------------------------------
_encryption=($(getStorageItemIndexesOfType encryption))
if [[ -n "$_encryption" ]]; then
    # Get passphrase (or use test mode passphrase)
    ${TEST:-false} && PASSPHRASE="testpassphrase" || \
        setPassphrase PASSPHRASE "disk encryption passphrase"
    # Encrypt partitions
    for _encrypted_item in ${_encryption}; do
        activateRecord $_encrypted_item
        printLog "Encrypting ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}..."
        if itemIsInSSD $_encrypted_item; then
            _ssd="${LUKS[OPEN,SSD]:-}}"
        else
            _ssd=""
        fi
        typeset -a _luks_format _luks_open
        _luks_format=(
            print -r "$PASSPHRASE" "| cryptsetup ${LUKS[FORMAT]:-}"
            luksFormat ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}
            )
        _luks_open=(
            print -r "$PASSPHRASE" "| cryptsetup open ${LUKS[OPEN]:-}"
            ${STORAGE[${_encrypted_item:0,1},SSD]:+${LUKS[OPEN,SSD]:-}}
            ${_ssd}
            ${STORAGE[${ACTIVE[PARENT]},DEVPATH]} ${ACTIVE[LABEL]}
            )
        evalSim ${_luks_format}
        evalSim ${_luks_open}
    done
    unset PASSPHRASE
else
    successLog "No encrypted storage items found; skipping encryption."
fi

:""<< \
-------------------------------------------------------------------------------
Activating swap
-------------------------------------------------------------------------------
_swap=($(getStorageItemIndexesOfType swap))
if (( ${#_swap} > 1 )); then
    errorLog "Multiple swap partitions listed; there can be only one."
    exit 1
elif (( ${#_swap} == 1 )); then
    activateRecord ${_swap}
    if itemIsInSSD $_swap; then
        _ssd="--discard"
    else
        _ssd=""
    fi
    if (( ${+ACTIVE[LABEL]} )); then
        evalSim mkswap -L ${ACTIVE[LABEL]} ${ACTIVE[DEVPATH]}
        evalSim swapon -L ${ACTIVE[LABEL]:-} ${_ssd}
    else
        typeset _uuid=$(getUUIDForDevpath ${ACTIVE[DEVPATH]})
        evalSim mkswap -U $_uuid ${ACTIVE[DEVPATH]}
        evalSim swapon -U $_uuid ${ACTIVE[LABEL]:-} ${_ssd}
    fi
    (( $? == 0 )) && successLog "Successfully activated Swap" || {
        errorLog "Failed to create/activate swap"; exit 1; }
fi

:""<< \
-------------------------------------------------------------------------------
Initializing filesystems
-------------------------------------------------------------------------------
for _filesystem in $(getStorageItemIndexesOfType filesystem); do
    activateRecord $_filesystem
    printLog "Creating ${ACTIVE[FSTYPE]} filesystem in ${ACTIVE[DEVPATH]}..."
    itemIsInSSD $_filesystem \
        && {
        print "SSD TRUE"
        _ssd="${MKFS[${(U)ACTIVE[FSTYPE]},SSD]:-}}"
        } || {
        print "SSD FALSE"
        _ssd=""
        }
    typeset -a _mkfs_options
    _mkfs_options=(
        ${MKFS[${(U)ACTIVE[FSTYPE]}]:-}
        ${_ssd}
        ${ACTIVE[MKFSOPTIONS]:-}
        )
        evalSim mkfs.${(L)ACTIVE[FSTYPE]} ${(e)_mkfs_options} ${ACTIVE[DEVPATH]}
done

:""<< \
-------------------------------------------------------------------------------
Mounting filesystems and initializing subvolumes
-------------------------------------------------------------------------------
# create ordered list of mountpoints so we mount them in the right order
typeset -A _mountpoint_list
typeset -T _MOUNTOPTIONS_CSV _mountoptions ","
_mountpoint_list=(${(kv)STORAGE[(I)*,MOUNTPOINT]})
for _mountpoint in ${(vo)_mountpoint_list}
do
    activateRecord ${(k)STORAGE[(r)$_mountpoint]%,MOUNTPOINT}
    if [[ "${ACTIVE[TYPE]}" == "subvolume" ]]
    then
        :
        # make a subvolume, etc.
    elif [[ "${ACTIVE[TYPE]}" == "filesystem" ]]
    then
        :
        # mount an existing filesystem
        _mountoptions=()
        _mountoptions+=(${MOUNTOPTIONS[COMMON]:-})
        _mountoptions+=("${MOUNTOPTIONS[${(U)ACTIVE[FSTYPE]}]:-}")
        itemIsInSSD $_filesystem && {
        _mountoptions+=(${MOUNTOPTIONS[SSD]:-})
        _mountoptions+=(${MOUNTOPTIONS[${(U)ACTIVE[FSTYPE]},SSD]:-})
        } || :
        _mountoptions+=(${ACTIVE[MOUNTOPTIONS]:-})
        xxx execute mount command
        
    else
        errorLog "\nStorage item type ${ACTIVE[TYPE]} should not have a" \
                 "mountpoint as listed in the storage definition file." || :
        printLog "Ignoring this mountpoint ($_mountpoint)!"
    fi
print -n "_MOUNTOPTIONS_CSV "
print "$_MOUNTOPTIONS_CSV"
done
exit

:<< EOF
# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNTOPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done
EOF

# vim: set filetype=sh :
