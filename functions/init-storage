#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 
:<< \
-------------------------------------------------------------------------------
Script environment
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
# here
(( ${+SCRIPT_ROOT} )) || {
    SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done
    }

:<< \
-------------------------------------------------------------------------------
Initialize variables and check arguments
-------------------------------------------------------------------------------
# initial declarations
# typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

[[ -n "${MOUNTROOT:-}" ]] \
    && MOUNTROOT="${MOUNTROOT:-}" || MOUNTROOT="${2:-/mnt}"

# set RAM and ram here; partition --size should be set to value "ram" with no
# leading "$", but in case it is, we'll set this here to not fail hard on
# what otherwise is an intuitive use of a variable. for reference, however,
# the storage definition file should use "partition --size ram"
RAM=$(print "$(( $(print ${$(cat /proc/meminfo \
    | grep -i memtotal)[2]}) / 1000000 ))G"); ram=$RAM

# fail if missing storage table filename/path argyment
[[ -n ${STORAGE_FILE:=${1:-}} ]] \
    || { errorLog "No storage table file specified." || usage 1; }

TMPSTOR="$TMPDIR/storage"
[[ -f "$TMPSTOR" ]] \
    && errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!"

:<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

typeset -A STOROPTS STORCMD

STORCMD[BTRFS]=''
STORCMD[BTRFS]=''
STORCMD[VFAT]=''
STORCMD[VFAT,SSD]=''
STORCMD[EXFAT]=''
STORCMD[EXT2]=''
STORCMD[EXT3]=''
STORCMD[EXT4]=''
STORCMD[F2FS]=''
STORCMD[JFS]=''
STORCMD[NILFS2]=''
STORCMD[NTFS]=''
STORCMD[REISER4]=''
STORCMD[REISERFS]=''
STORCMD[XFS]=''
STORCMD[ZFS]=''

STOROPTS[MKFS,COMMON]=''
STOROPTS[MKFS,SSD]=''
STOROPTS[MKFS,BTRFS]='--force --label $_record_label'
STOROPTS[MKFS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
STOROPTS[MKFS,VFAT]='-F32 -n $_record_label'
STOROPTS[MKFS,VFAT,SSD]=''
STOROPTS[MKFS,EXFAT]=''
STOROPTS[MKFS,EXT2]=''
STOROPTS[MKFS,EXT3]=''
STOROPTS[MKFS,EXT4]=''
STOROPTS[MKFS,F2FS]=''
STOROPTS[MKFS,JFS]=''
STOROPTS[MKFS,NILFS2]=''
STOROPTS[MKFS,NTFS]=''
STOROPTS[MKFS,REISER4]=''
STOROPTS[MKFS,REISERFS]=''
STOROPTS[MKFS,XFS]=''
STOROPTS[MKFS,ZFS]=''

STOROPTS[MOUNT,COMMON]='rw'
STOROPTS[MOUNT,SSD]='noatime'
STOROPTS[MOUNT,BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
STOROPTS[MOUNT,BTRFS,SSD]='ssd,discard_space'
STOROPTS[MOUNT,VFAT]='-F32 -n $_record_label'
STOROPTS[MOUNT,VFAT,SSD]=''
STOROPTS[MOUNT,EXFAT]=''
STOROPTS[MOUNT,EXT2]=''
STOROPTS[MOUNT,EXT3]=''
STOROPTS[MOUNT,EXT4]=''
STOROPTS[MOUNT,F2FS]=''
STOROPTS[MOUNT,JFS]=''
STOROPTS[MOUNT,NILFS2]=''
STOROPTS[MOUNT,NTFS]=''
STOROPTS[MOUNT,REISER4]=''
STOROPTS[MOUNT,REISERFS]=''
STOROPTS[MOUNT,XFS]=''
STOROPTS[MOUNT,ZFS]=''

# Note that --force-password allows weak passphrases (for testing only)
STOROPTS[LUKS,FORMAT]='--force-password'
STOROPTS[LUKS,OPEN]=''
STOROPTS[LUKS,OPEN,SSD]='--allow-discards'

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical storage table file
-------------------------------------------------------------------------------
# source remote URI or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]
then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]
then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
            "\nCheck your storage subdirectory and naming." \
            "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]
then
    errorLog "Could not find storage table file at path $STORAGE_FILE."

fi


:""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------

# The valid options (boolean and scalar separate) for storage items.
# Not all options are valid for all types, but this is at least a basic
# sanity check. Used in the convertStorageFileToArray function, listed
# here as this is the one stop location for adding/removing/renaming.
typeset -a STOROPTS_SCAL STOROPTS_BOOL
STOROPTS_BOOL=(bootable noclobber ssd)
STOROPTS_SCAL=(devpath fstype label code mountopts mountpoint size type)

# a little too dependent on state, but it's not easy to functionally
# pass associative arrays around so this will write out to the
# global STORAGE array. This could be passed at least as an explicit
# --output argument (i.e. the name of the array) but indirect references
# to associative array values are ridiculous looking in zsh.
typeset -A STORAGE
convertStorageFileToArray --input $STORAGE_FILE \
    && successLog "Storage file successfully converted for processing." \
    || errorLog "Failed to converted storage file for processing." \

# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
#MOUNTPOINTS=(${(vo)STORAGE[(I)*,MOUNTPOINT]})

:""<< \
-------------------------------------------------------------------------------
Identifying installation drive(s)
-------------------------------------------------------------------------------
# Uses either the preset --devpath value for drives from the storage file or
# interactively selects the drive

# If a drive devpath is not set (normally will be unset), prompt for it here

_drives=($(getStorageItemIndexesOfType drive))
_unmounted_drives="$(getUnmountedDrives)"
for _drive in $_drives
do
    debugLog "Checking drive $_drive"
    if [[ -z "${STORAGE[$_drive,DEVPATH]:-}" ]]
    then
        _msg="Please select a drive for installation"
        alertLog "\n\n$_msg"
        if (( ${#_drives} > 1 )); then
            printLog "(drive $_drive of ${#_drives})\n"
        else
            printLog "(single drive installation)\n"
        fi
        selectDrive DRIVEPATH
        STORAGE[$_drive,DEVPATH]="${DRIVEPATH:-}"
        [[ -z "$SSD" ]] || {
        print "YES IS SSD" # debug DEBUG xxx
        STORAGE[$_drive,SSD]="true"
    }
    else
        # set a flag so that we know a drive device path has been picked using
        # a value from the storage file... we want to confirm again if this is
        # the case...
        valueIsInList --value ${STORAGE[$_drive,DEVPATH]} --list "$_unmounted_drives" || {
        $(${TEST:-false} && print "printLog" || print "errorLog") \
                "${STORAGE[$_drive,DEVPATH]} is specified explicitly in storage" \
                "definition file but is currently\nmounted or inaccessible." || exit 1
            }
        STORAGE[FILEPICKEDPATH]=true
    fi
done

# if any of the drive paths were set directly from the storage file, confirm
# before proceeding (no auto erasure)
if (( ${+STORAGE[FILEPICKEDPATH]} ))
then
    (( ${#$(getStorageItemIndexesOfType drive)} > 1 )) && s="s" || s=""
    # (( ${#_drives} > 1 )) && s="s" || s=""
    ${SIM:-false} || alertLog "IMPORTANT - DATA WILL BE ERASED!"
    printLog "Installation will occur to the following device$s:\n"
    for _drive in $(getStorageItemIndexesOfType drive)
    do
        printLog "DRIVE $_drive device path: ${STORAGE[$_drive,DEVPATH]}"
    done
    ${FORCE:-false} || {
        queryLog "\nEnter'y' to install to drive$s listed, 'q' to quit: (y/q) "
        read -k CONFIRM ||:; [[ ${(L)CONFIRM} == "y" ]] || {
        printLog "\n\nUser selected exit.\n"; exit 0 }
        }
fi

:""<< \
-------------------------------------------------------------------------------
Assembling device paths on target drive(s)
-------------------------------------------------------------------------------
# following function assigns valid device paths to all STORAGE items
makeDevPaths \
    && successLog "Assembled device paths successfully." \
    || errorLog "Failed to assemble device paths."

debugLog "\nSTORAGE ARRAY VALUES:\n"
for _childkey in ${(ovps: :)STORAGE[(I)*CHILDREN]}; do
    for _key in ${(ok)STORAGE[(I)$_childkey,[^[:digit:]]*]}; do
        debugLog "$_key: ${STORAGE[$_key]}"
    done
done

#debugLog "\n\nOrder of initialization:"
#debugLog ${STORAGE[CHILDREN]}
#debugLog ${(ov)STORAGE[(I)*CHILDREN]}

:<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS!
-------------------------------------------------------------------------------
${SIM:-false} || :""""<<< "INSTALLATION BEGINNING... DATA WILL BE ERASED!"

:<< \
'-------------------------------------------------------------------------------'
DEBUG for second pass
# DEBUGGING - turn off active swap
swapoff -a

# DEBUGGING close any open crypt devices 
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} == luks ]]; then
        cryptsetup close $_record_label &>/dev/null || :
    fi
    unsetActiveStorageRecordWithPrefix _record
done
-------------------------------------------------------------------------------

:""<< \
-------------------------------------------------------------------------------
Erasing/preparing target drive(s)
-------------------------------------------------------------------------------
for _drive in $(getStorageItemIndexesOfType drive); do
    activateRecord $_drive
    if (( ${+ACTIVE[NOCLOBBER]} )); then
        alertLog "\nNoclobber option set on drive $_drive !"
        printLog "\nNoclobber prevents all changes to a drive. This is likely"\
                 "not what you intended. \nnoclobber should be used on "\
                 "existing partitions or filesystems)\n"
        exit 1
    else
        alertLog "\nPreparing to erase drive $_drive... ${_SIM}"
        ${TEST:-false} && _c=0 || _c=5
        ${SIM:-false} || countdownMsg $_c "Erasing drive ${ACTIVE[DEVPATH]}"
        evalSim  sgdisk --zap-all ${ACTIVE[DEVPATH]} # erase everything!
        evalSim  sgdisk --clear ${ACTIVE[DEVPATH]}   # create new gpt structure
        ${SIM:-false} || successLog "Drive ${ACTIVE[DEVPATH]} erased!"
    fi
done

:""<< \
-------------------------------------------------------------------------------
Processing partitions
-------------------------------------------------------------------------------
_partitions=($(getStorageItemIndexesOfType partition))
if [[ -n "${_partitions}" ]];
then

    # check for bootable option or, if single partition, make it bootable
    # TODO: there may be edge cases where making a single partition bootable
    # is not desirable.
    if (( ${#_partitions} > 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        errorLog "At least one partition must have the --bootable option in" \
            "the storage item\ndefinition file"
    elif (( ${#_partitions} == 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        # single partition, set as bootable
        STORAGE[${_partitions},BOOTABLE]=true
    fi

    typeset -a _sgdisk_cmd
    for _drive in $(getStorageItemIndexesOfType drive); do
        activateRecord $_drive
        _drive_devpath=${ACTIVE[DEVPATH]}
        for _partition in \
            $(getStorageItemIndexesOfTypeForParent partition $_drive)
        do
            activateRecord $_partition
            printLog "Preparing formatting command for ${ACTIVE[DEVPATH]}"
            _id=${ACTIVE[DEVPATH][-1]}
            if [[ ${(L)ACTIVE[SIZE]} =~ "^max" ]]; then
                _sgdisk_cmd+=("--largest-new=${_id}")
            elif [[ ${(L)ACTIVE[SIZE]} =~ "ram" ]]; then
                _sgdisk_cmd+=("--new=${_id}:0:+$RAM")
            else
                _sgdisk_cmd+=("--new=${_id}:0:+${ACTIVE[SIZE]}")
            fi
            if [[ -n "${(L)ACTIVE[BOOTABLE]:-}" ]]; then
                _sgdisk_cmd+=("--attributes=${_id}:set:0")
            fi
            #[[ -z "${ACTIVE[CODE]:-}" ]] || \
            #    _sgdisk_cmd+=("--typecode=${_id}:${ACTIVE[CODE]}")
            _sgdisk_cmd+=(${ACTIVE[CODE]:+--typecode=${_id}:${ACTIVE[CODE]}})
            _sgdisk_cmd+=(${ACTIVE[LABEL]:+--change-name=${_id}:${(q-)ACTIVE[LABEL]}})
        done
        _sgdisk_cmd+=($_drive_devpath)
        evalSim "print 'Partitioning...' && sgdisk $_sgdisk_cmd && print 'Partitions created successfully' || { print 'Partition creation failed'; exit 1; }"
    done
else
    # TODO: can add in an fstype validity check here and remove warning
    alertLog "No partitions listed as children of drives! Ensure you have" \
        "specified a\nfilesystem type that can be initialized directly to a" \
        "drive without a partition.\nPROCEEDING..."
fi

:""<< \
-------------------------------------------------------------------------------
Encrypting storage
-------------------------------------------------------------------------------

_encryption=($(getStorageItemIndexesOfType encryption))

if [[ -n "$_encryption" ]]; then
    # Get passphrase (or use test mode passphrase)
    ${TEST:-false} && PASSPHRASE="testpassphrase" || \
        setPassphrase PASSPHRASE "disk encryption passphrase"
    # Encrypt partitions
    for _encrypted_item in ${_encryption}; do
        activateRecord $_encrypted_item
        printLog "Encrypting ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}..."
        _ssd="${STORAGE[${_encrypted_item:0,1},SSD]:+${STOROPTS[LUKS,OPEN,SSD]:-}}"
        _ssd="${STORAGE[${_encrypted_item:0,1},SSD]:+${STOROPTS[LUKS,OPEN,SSD]:-}}"
        typeset -a _luks_format _luks_open
        _luks_format=(
            print -r "$PASSPHRASE" "| cryptsetup ${STOROPTS[LUKS,FORMAT]:-}"
            luksFormat ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}
            )
        _luks_open=(
            print -r "$PASSPHRASE" "| cryptsetup open ${STOROPTS[LUKS,OPEN]:-}"
            ${STORAGE[${_encrypted_item:0,1},SSD]:+${STOROPTS[LUKS,OPEN,SSD]:-}}
            ${STORAGE[${ACTIVE[PARENT]},DEVPATH]} ${ACTIVE[LABEL]}
            )
        evalSim ${_luks_format}
        evalSim ${_luks_open}
    done
    unset PASSPHRASE
else
    successLog "No encrypted storage items found; skipping encryption."
fi

:""<< \
-------------------------------------------------------------------------------
Activating swap
-------------------------------------------------------------------------------
_swap=($(getStorageItemIndexesOfType swap))
if (( ${#_swap} > 1 )); then
    errorLog "Multiple swap partitions listed; there can be only one."
    exit 1
elif (( ${#_swap} == 1 )); then
    activateRecord ${_swap}
    if (( ${+ACTIVE[LABEL]} )); then
        evalSim mkswap -L ${ACTIVE[LABEL]} ${ACTIVE[DEVPATH]}
        evalSim swapon -L ${ACTIVE[LABEL]:-}
    else
        typeset _uuid=$(getUUIDForDevpath ${ACTIVE[DEVPATH]})
        evalSim mkswap -U $_uuid ${ACTIVE[DEVPATH]}
        evalSim swapon -U $_uuid ${ACTIVE[LABEL]:-}
    fi
    (( $? == 0 )) && successLog "Successfully activated Swap" || {
        errorLog "Failed to create/activate swap"; exit 1; }
fi
exit

:""<< \
-------------------------------------------------------------------------------
Initializing filesystems
-------------------------------------------------------------------------------

            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path

            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNT_OPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done

# vim: set filetype=sh :
