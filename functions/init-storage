#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 
:<< \
-------------------------------------------------------------------------------
Script environment
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
# here
(( ${+SCRIPT_ROOT} )) || {
    SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done
    }

:<< \
-------------------------------------------------------------------------------
Initialize variables and check arguments
-------------------------------------------------------------------------------
# initial declarations
# typeset -Ax SCRIPT DATAPATHS AUTOPATHS MANIFEST CONFIG INSTALLER USER STORAGE

[[ -n "${MOUNTROOT:-}" ]] \
    && MOUNTROOT="${MOUNTROOT:-}" || MOUNTROOT="${2:-/mnt}"

RAM=$(print "$(( $(print ${$(cat /proc/meminfo \
    | grep -i memtotal)[2]}) / 1000000 ))G")

# fail if missing storage table filename/path argyment
[[ -n ${STORAGE_FILE:=${1:-}} ]] \
    || { errorLog "No storage table file specified." || usage 1; }

TMPSTOR="$TMPDIR/storage"
[[ -f "$TMPSTOR" ]] \
    && errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!"

:<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

typeset -A STOROPTS STORCMD

STORCMD[BTRFS]=''
STORCMD[BTRFS]=''
STORCMD[VFAT]=''
STORCMD[VFAT,SSD]=''
STORCMD[EXFAT]=''
STORCMD[EXT2]=''
STORCMD[EXT3]=''
STORCMD[EXT4]=''
STORCMD[F2FS]=''
STORCMD[JFS]=''
STORCMD[NILFS2]=''
STORCMD[NTFS]=''
STORCMD[REISER4]=''
STORCMD[REISERFS]=''
STORCMD[XFS]=''
STORCMD[ZFS]=''

STOROPTS[MKFS,COMMON]=''
STOROPTS[MKFS,SSD]=''
STOROPTS[MKFS,BTRFS]='--force --label $_record_label'
STOROPTS[MKFS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
STOROPTS[MKFS,VFAT]='-F32 -n $_record_label'
STOROPTS[MKFS,VFAT,SSD]=''
STOROPTS[MKFS,EXFAT]=''
STOROPTS[MKFS,EXT2]=''
STOROPTS[MKFS,EXT3]=''
STOROPTS[MKFS,EXT4]=''
STOROPTS[MKFS,F2FS]=''
STOROPTS[MKFS,JFS]=''
STOROPTS[MKFS,NILFS2]=''
STOROPTS[MKFS,NTFS]=''
STOROPTS[MKFS,REISER4]=''
STOROPTS[MKFS,REISERFS]=''
STOROPTS[MKFS,XFS]=''
STOROPTS[MKFS,ZFS]=''

STOROPTS[MOUNT,COMMON]='rw'
STOROPTS[MOUNT,SSD]='noatime'
STOROPTS[MOUNT,BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
STOROPTS[MOUNT,BTRFS,SSD]='ssd,discard_space'
STOROPTS[MOUNT,VFAT]='-F32 -n $_record_label'
STOROPTS[MOUNT,VFAT,SSD]=''
STOROPTS[MOUNT,EXFAT]=''
STOROPTS[MOUNT,EXT2]=''
STOROPTS[MOUNT,EXT3]=''
STOROPTS[MOUNT,EXT4]=''
STOROPTS[MOUNT,F2FS]=''
STOROPTS[MOUNT,JFS]=''
STOROPTS[MOUNT,NILFS2]=''
STOROPTS[MOUNT,NTFS]=''
STOROPTS[MOUNT,REISER4]=''
STOROPTS[MOUNT,REISERFS]=''
STOROPTS[MOUNT,XFS]=''
STOROPTS[MOUNT,ZFS]=''

# Note that --force-password allows weak passphrases (for testing only)
STOROPTS[LUKS,FORMAT]='--force-password'
STOROPTS[LUKS,OPEN]=''
STOROPTS[LUKS,OPEN,SSD]='--allow-discards'

:""<< \
-------------------------------------------------------------------------------
Loading & processing atypical storage table file
-------------------------------------------------------------------------------
# source remote URI or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]; then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]; then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]; then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
                 "\nCheck your storage subdirectory and naming." \
                 "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]; then
    errorLog "Could not find storage table file at path $STORAGE_FILE."
fi


:""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------

# note use of 'e' expansion flag to parse variables like $RAM

zmodload zsh/zutil

unset STORAGE; typeset -A STORAGE

# only these storage types allowed
VALID_STORAGE_TYPES=(
    DRIVE
    PARTITION
    LOGICAL
    ENCRYPTION
    FILESYSTEM
    SUBVOLUME
    )

typeset -A COMPLIANCE
COMPLIANCE[CHILD_OF,DRIVE]="
    [[ _type == partition ]] || \
    [[ _type == encryption ]] || \
    [[ _type == logical ]] || \
    [[ _type == filesystem && _filesystemtype == btrfs ]] || \
    [[ _type == filesystem && _filesystemtype == ext4 ]] "
COMPLIANCE[CHILD_OF,PARTITION]="
    [[ _type == encryption ]] || \
    [[ _type == filesystem ]] "
COMPLIANCE[CHILD_OF,FILESYSTEM]="
    [[ _type == subvolume  ]] && \
    [[ _filesystemtype == btrfs ]] && \
    [[ _mountpoint is in parent mount point ]] "
COMPLIANCE[CHILD_OF,SUBVOLUME]="
    [[ _type == subvolume  && _filesystemtype == btrfs ]] "

# storage items boolean option array names
BOOLEAN_OPT_ARRAYS=(
    BOOTABLE
    NOCLOBBER
    )

# storage items scalar option array names
SCALAR_OPT_ARRAYS=(
    CODE
    DEVPATH
    FSTYPE
    LABEL
    MOUNTPOINT
    MOUNTOPTS
    SIZE
    TYPE
    )

eval "typeset -a $BOOLEAN_OPT_ARRAYS $SCALAR_OPT_ARRAYS"

# _parse_storage_item handles the pseudo commands such as:
#     drive
#         partition --label "MyLabel"
#         partition --label "AnotherPartition"
# from the storage stable file, parsing them into array
# values.
_parse_storage_item () {

    # increment index
    typeset -g ITEMINDEX=+1

    # make sure storage is set
    typeset -gA STORAGE

    # handle variations on allowed options
    zmodload zsh/zutil
    zparseopts -D -E \
        b::-=BOOTABLE -boot::-=BOOTABLE -bootable::-=BOOTABLE \
        n::-=NOCLOBBER -noclobber::-=NOCLOBBER \
        c:=CODE -code:=CODE \
        d:=DEVPATH p:=DEVPATH -path:=DEVPATH \
            -device:=DEVPATH -devpath:=DEVPATH \
        f:=FSTYPE -fs:=FSTYPE -fstype:=FSTYPE -filesystem:=FSTYPE \
        i:=INDEX -id:=INDEX -idx:=INDEX -index:=INDEX \
        l:=LABEL -label:=LABEL \
        m:=MOUNTPOINT -mount:=MOUNTPOINT -mountpoint:=MOUNTPOINT \
        -null=NULL \
        o:=MOUNTOPTS -options:=MOUNTOPTS \
            -mountopts:=MOUNTOPTS -mountoptions:=MOUNTOPTS \
        s:=SIZE -size:=SIZE \
            -sub:=SUBSCRIPT -subscript:=SUBSCRIPT \
        t:=TYPE -type:=TYPE

    # _subh (subscript, head)
    # _subt (subscript, tail)
    typeset _sub
    _subh="${(U)SUBSCRIPT[2]:-}"
    _subt="${(U)TYPE[2]}${INDEX[2]:+_}${INDEX[2]}"
    _subht="${_subh}${_subh:+,}${_subt}"

    # assign values to indexed storage item parameters
    # (scalar values)
    for _optname in $SCALAR_OPT_ARRAYS
    do
        if [[ -n "${(P)_optname:-}" ]]
        then
            eval _${(U)_optname}'="${${'$_optname'[2]:-}#=}"'
            STORAGE[${_subht},${(U)_optname}]="${(P)${:-_${(U)_optname}}}"
        fi
    done

    # assign values to indexed storage item parameters
    # (boolean values)
    for _optname in $BOOLEAN_OPT_ARRAYS
    do
        if [[ -n "${(P)_optname:-}" && ! "${(LP)_optname:-}" =~ ".*false" ]]
        then
            eval _${(U)_optname}'=true'
            STORAGE[${_subht},${(U)_optname}]=true
        fi
    done

    # create a null entry for testing so we know this item exists
    # (required in case item has no other parameters)
    STORAGE[${_subht},EXISTS]=true

    # add child to parent subscript entry
    # TODO: may not be necessary (could just write a simple helper
    # lookup function to return same data...
    if [[ -n "${_subh:-}" ]]; then
        #STORAGE[${_subh}${_subh:+,}CHILDREN]="${STORAGE[${_subh}${_subh:+,}CHILDREN]:-} ${(U)TYPE[2]}${INDEX[2]:+_}${INDEX[2]}"
        :
    fi

    if [[ -n "$@" ]]; then
        errorLog "Unknown storage options: $@" \
                 "\nCheck for correct spelling," \
                 "formatting, option dashes, etc."
    fi

    }

_generate_storage_commands_from_file () {
    # _opts contains the arguments passed to this function

    typeset -A _opts
    zmodload zsh/zutil
    zparseopts -D -E -A _opts -inputfilepath: -outputarrayname:
    _inputfilepath="${${_opts[--inputfilepath]:-}#=}"
    _outputarrayname="${${_opts[--outputarrayname]:-}#=}"

    # initialization
    if [[ -n "$_inputfilepath" && -n "$_outputarrayname" ]]
    then

        typeset -ag PAYLOAD STORAGE_CMDS $_outputarrayname
        typeset -a STORAGE_FILE_DATA
        typeset -Ag CHILDREN

        # read storage file into array
        STORAGE_FILE_RAW_DATA=(${(f)"$(<$_inputfilepath)"})

        # strip comments (full or partial)
        # merge escaped newlines into single lines
        for _line in "${(@)STORAGE_FILE_RAW_DATA}";
        do

            # if this line isn't blank or a comment, continue to process
            if [[ -n "${_line::=${_line//\#*}}" \
               && ! "$_line" =~ "^[[:space:]]*$" ]]; then

                # if this line ends in an escaped newline, prep to merge with next
                if [[ "${_line[-1]}" == \\ ]]; then
                    # set as previous line (and append if we have escaped
                    # newlines on multiple sequential lines)
                    _prev_line="${_prev_line:-}$_line[1,-2]"

                # otherwise assign line to payload (merging with any prev line)
                else
                    _line="${_prev_line:-}$_line"
                    _indent="${#${_line}%%[^[:space:]]*}"
                    PAYLOAD+=("--type ${_line:${_indent}:${#_line}} --item_indent $_indent")
                    _prev_line=""
                fi
            fi
        done
    elif [[ -n "$_inputfilepath" || -n "$_outputarrayname" ]]; then
        errorLog "$0 requires both a filepath and output arrayname."
    fi

    # _build_tree eats PAYLOAD line by line (inner function here since
    # we are doing things with state internal to the _gen function
    _initialize_tree_values () {
        typeset -i _item_index=0 # sequence index for siblings (partition 1, 2, etc.)
        while (( ${#PAYLOAD} )); do
            # head and tail the payload
            # (--null is just to make sure we can pull out a single word for
            # the subscript later on... a silly hack, probably a better way
            # using a different zsh expansion)
            _head="${(@)PAYLOAD[1]:-}";
            eval set -- "$@ $_head"
            _parse_opts=(item_indent section_indent base_indent parent_index)
            #for _opt in "${(@)_parse_opts}"
            #do
            #    eval "zparseopts -E -$_opt:=_$_opt"
            #    eval "_$_opt[1]=()"
            #done
            zparseopts -E -item_indent:=_item_indent \
                          -section_indent:=_section_indent \
                          -base_indent:=_base_indent \
                          -parent_index:=_parent_index
            _item_indent[1]=()
            _section_indent[1]=()
            _base_indent[1]=()
            _parent_index[1]=()

            print "SECTION: $_section_indent    ITEM: $_item_indent"
            # item is a peer of the current section
            if (( $_item_indent == ${_section_indent:-$_base_indent} ))
            then
                _item_index+=1
                _full_index="${_parent_index:-}${_parent_index:+,}${_item_index}"
                STORAGE[$_full_index]="$_head"
                # trim payload for next go round
                PAYLOAD[1]=()

            # item is a child of the current section
            elif (( $_item_indent > ${_section_indent:-$_base_indent} ))
            then
                _full_index="${_parent_index:-}${_parent_index:+,}${_item_index}"
                $0  --base_indent "$_base_indent" \
                    --section_indent "$_item_indent" \
                    --parent_index "$_full_index"
                    
                # now get the immediate children of this level

            elif (( $_item_indent < ${_section_indent:-$_base_indent} ))
            then

                # payload head is superior to current level, so return from
                # recursive call until we get back to a peer level
                return 0

            fi
        done
        }

    _initialize_tree_values --base_indent "${#${PAYLOAD[1]}%%[^[:space:]]*}"

}

:<< 'EOF'
STORAGE[1,ARGS]="--type drive --index 1 --children '1,1 1,2 1,3' --childtypes 'part part encryption'"
STORAGE[1,TYPE]="drive"
STORAGE[1,CHILDREN,INDEXES]="1,1 1,2 1,3"
STORAGE[1,CHILDREN,TYPES]="part part encryption"

STORAGE[1,1,1]="type=drive index=1" 
EOF

_generate_storage_commands_from_file \
        --inputfilepath $STORAGE_FILE \
        --outputarrayname STORAGE_COMMANDS 
for k in ${(ok)STORAGE[@]}; do
        print "$k: ${STORAGE[$k]}"
done

exit

# _make_storage_commands_from_file
#
# iterates over the storage file data pseudo-commands and is
# responsible for creating the correct array subscript and numbering
# peers (partition 1, drive 2, etc.)
_make_storage_commands_from_file () {

    # _opts contains the arguments passed to this function
    # _level is typeset here to make it local to all recursive calls
    # without this typeset, it is local to the function but exports itself
    # to subsequent calls
    # _index is the peer level item index (e.g. drive 1, drive 2)

    typeset -A _opts
    typeset _head _tail _level _parent _payload _prev_type _prev_index _filename
    typeset -i _index=0
    typeset -i _seq
    typeset -g _outputarrayname

    # get the currently being processed indent level and subscript if being
    # called recursively, or set defaults

    zmodload zsh/zutil
    zparseopts -D -E -A _opts -level: -parent: -filename: -outputarrayname:
    _level="${${_opts[--level]:-0}#=}"
    _seq="${${_opts[--seq]:-0}#=}"
    _filename="${${_opts[--filename]:-}#=}"
    _outputarrayname="${${_opts[--outputarrayname]:-}#=}"
    _parent="${${_opts[--parent]:-}#=}"
    _payload="${${_opts[--payload]:-}#=}"

    # initialize payload (a global common to all recursive calls)
    # parse remaining options in such a way that we handle both incoming
    # multiple line, single argument strings and multiple single line arrays
    #
    # PAYLOAD is the incoming, sanitized storage file data (sanitized only
    # by merging escaped newlines and stripping comments/blank lines)
    # STORAGE_CMDS is the array of the to-be-executed pseudo commands
    # CHILDREN is an array of children values for each command, used to
    # check basic compliance (a drive can't be a child of a drive, etc.)

    # begin one time initialization
    (( ${+PAYLOAD} )) || {
        typeset -ag PAYLOAD STORAGE_CMDS STORAGE_FILE_DATA $_outputarrayname
        typset -Ag CHILDREN
        # read storage file into array, stripping comments and merging escaped
        # newlines into single lines
        STORAGE_FILE_RAW_DATA=(${(f)"$(<$_filename)"})
        for _line in "${(@)STORAGE_FILE_RAW_DATA}";
        do
            # trim comments, skip blank lines
            if [[ -n ${_line::=${_line//\#*}} && ! "$_line" =~ "^[[:space:]]*$" ]];
            then
                if [[ "${_line[-1]}" == \\ ]]; then
                    _prev_line="$_line[1,-2]"
                else
                    PAYLOAD=(${(@)STORAGE_DATA:-} "${_prev_line:-}$_line")
                    _prev_line=""
                fi
            fi
        done
        for _item in $@; do PAYLOAD=(${(@)PAYLOAD:-} ${(f)_item}); done;
        # reset level to initial item in case the entire block of storage
        # items has been indendent for some reason
        _level="${#${${(@)PAYLOAD[1]:-}}%%[^[:space:]]*}"
        }

    # eat up the payload line by line, converting it to pseudo commands
    while (( ${#PAYLOAD} )); do

        # head and tail the payload
        # (--null is just to make sure we can pull out a single word for
        # the subscript later on... a silly hack, probably a better way
        # using a different zsh expansion)
        _head=(${(@)PAYLOAD[1]:-} --null); _tail=(${(@)PAYLOAD[2,-1]:-})

        # determine the indendation level
        _head_level="${#${_head}%%[^[:space:]]*}"

        if (( $_head_level == $_level ))
        then

            # Payload head is peer of the current level so we execute it
            # as a pseudo command that processes its options into array
            # (we also strip whitespace from head for cleaner debug
            # output). For example, the initial line of a payload should be
            # "drive ..." and the initial level will be 0, so 

            _index+=1

            #eval "_parse_storage_item --type ${(z)_head}" \
            #     "--index $_index --parent \"$_parent\""

            _cmd="_parse_storage_item --type ${(z)_head}"
            _cmd+=" --index $_index --parent \"$_parent\""

            STORAGE_CMDS=("${(@)STORAGE_CMDS:-}" "$_cmd")

            _prev_type="${${(ps: :)${_head}}[1]}"
            _prev_index="${_index}"
            PAYLOAD=(${(@)_tail})
            (( ${_recursion} > 0 )) && CHILDREN[${_recursion:-}]+=(
            "--childtype=${_prev_type}"
            ) 

        elif (( $_head_level > $_level ))
        then

            # payload head is child of the current _level value, so recurse
            _make_tree --level $_head_level \
            --parent "${_parent}${_parent:+,}${_prev_type}_${_index}"

            
            # now get the immediate children of this level


            
        elif (( $_head_level < $_level )); then

            # payload head is superior to current level, so return from
            # recursive call until we get back to a peer level
            return 0

        fi
    done

    }

_compliance_check () {
:
}

_get_children_of () {
    print -l ${(o)${(k)STORAGE[(I)${1}*EXISTS]}%,EXISTS}
}

_get_parent_of () {
:
}


#_make_tree $STORAGE_DATA
_make_commands_from_file --filename $STORAGE_FILE --outputarrayname STORAGE_CMDS
print -l "${(@)STORAGE_CMDS}"

_compliance_check STORAGE

#_get_children_of DRIVE_1
#exit

print all existing items in storage array
print -l ${(o)${(k)STORAGE[(I)*EXISTS]}%,EXISTS}
#print -l ${(o)${(kv)STORAGE[(I)*CHILDREN]}}
exit

exit

:<< \
SECTION
complianceCheck
    each item type has a series of compliance checks
parse all items
    need to check to see hwat the children/parents are of each item


compliance[drive]=(
must have at least one child of type partition or fsype btrfs
if has path set, must prompt for noclobber
if has path set, must exist
)

compliance[part]=(
parent must be drive
)

parsentry () {

}
alias drive="scanEntry"
etc.


scanPeers () {
}

summarizeChildren
SECTION

source $STORAGE_FILE;

print ">>>>>"
print -l "${(kv)STORAGE}"
print ">>>>>"


# Ordered list of mounts for use in later loops.
# Useful in particular so that we have a naturally ordered list
# of mounts from / on down.
MOUNT_POINTS=(${(vo)STORAGE_RECORDS[(I)*,MOUNT_POINT]})

:""<< \
-------------------------------------------------------------------------------
Selecting target install drive
-------------------------------------------------------------------------------
# Interactively selects installation target and assigns to var DRIVE

# Create list of drives and remove mounted drives from list
typeset -a drives
drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
debugLog "Full list of drives: $drives"

# check if device or child has an existing mountpoint and remove from drives
# array if so
for drive in $drives; do
    { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $drive)" ]] \
      || mount | grep $drive; } && drives=("${(@)drives:#$drive}") || :
done
debugLog "List of drives with no mountpoint: $drives"

# User selects drive for install
userQuit () { printLog "\nUser selected quit."; exit; }
local CONFIRM="" SELECTED="" i=0
while [[ ! $CONFIRM =~ [Yy] ]]; do

    # list drives
    printLog "Available unmounted drives for installation:\n"
	for drive in $drives; do
        alertLog "[$(( i += 1))] $drive ($(/usr/bin/lsblk -dno SIZE $drive))"
    done

    # Pick drive or quit
	queryLog "\nPlease enter the number of the drive you wish to install to," \
             "or 'q' to quit: (1$((($i > 1)) && queryLog "-$i")/q) "
	while [[ -z $SELECTED || ! $SELECTED =~ [1-$i] && ! ${(L)SELECTED} == q ]]
    do
        queryLog "\b \b"
        read -k 1 SELECTED || : # read returns an error code at EOF; ignore it
    done
    [[ $SELECTED != "q" ]] || userQuit

    # Identify as SSD or standard
	queryLog "\nIs $drives[$SELECTED] an SSD? (y/N):"
    read -k SSD || :; [[ ${(L)SSD} == y ]] && SSD="" || unset SSD; echo

    # Summarize and confirm
	alertLog "\n\nYou have selected $drives[$SELECTED] for"\
             "COMPLETE ERASURE, and identified it as ${SSD-NOT }an SSD."
    queryLog "Enter'y' to erase, 'n' to make changes, or 'q' to quit: (y/N/q) "
    read -k CONFIRM ||:; [[ ${(L)CONFIRM} != "q" ]] || userQuit
done

DRIVE=$drives[$SELECTED]

alertLog "Installation to $DRIVE beginning..."

exit

:""<< \
-------------------------------------------------------------------------------
Assembling installation paths on target drive
-------------------------------------------------------------------------------
# Assign the parent device/storage container path to it's children
# The table is positionally semantic, i.e. order matters though
# only for the assignment of /dev/sdx# partition numbers
_partition_index=0
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if (( ${_record_parent_index:-0} == 0 ));
    then # no parent, so partition path will be something like /dev/sdx1
        (( _partition_index += 1 ))
        STORAGE_RECORDS[${_record_index},DEVICE_INDEX]=$_partition_index
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=${DRIVE}$_partition_index
    elif [[ ${(L)_record_parent_fstype} == "luks" ]];
    then # luks child, so /dev/mapper/parentlabel path
        _mapped_device_path=/dev/mapper/$_record_parent_label
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_mapped_device_path
    elif [[ ${(L)_record_parent_fstype} == "btrfs" ]];
    then # btrfs subvolume (children must always follow parents in table for
         # this to work unless I change the logic of this loop)
        STORAGE_RECORDS[${_record_index},DEVICE_PATH]=$_record_parent_device_path
        STORAGE_RECORDS[${_record_index},BTRFS,SUBVOLUME]=true
    else
        print "\n\nERROR: Unknown parent/child relationship found."
        print "Storage table entry #${_record_index}, label: ($_record_label)"
        print "Child FSTYPE:  $_record_fstype"
        print "Parent FSTYPE: $_record_parent_fstype"
        print "\nExiting.\n"
        exit 1
    fi
    unsetActiveStorageRecordWithPrefix _record
done

:<< \
-------------------------------------------------------------------------------
Child/Parent storage functions
-------------------------------------------------------------------------------
phys,erase,luks
phys,erase,btrfs


:<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS
-------------------------------------------------------------------------------

:<< \
-------------------------------------------------------------------------------
DEBUG for second pass
-------------------------------------------------------------------------------
# DEBUGGING - turn off active swap
swapoff -a

# DEBUGGING close any open crypt devices 
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} == luks ]]; then
        cryptsetup close $_record_label &>/dev/null || :
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Erase drive, create new GPT structure, and create partitions
storageGeneratePartitioningCommandForDrive _part_command $DRIVE
eval "$_part_command"

:<< \
-------------------------------------------------------------------------------
ENCRYPT STORAGE
-------------------------------------------------------------------------------

# Check if we need encryption
ENCRYPTION=false
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    [[ ${(L)_record_fstype} == luks ]] && ENCRYPTION=true || :
    unsetActiveStorageRecordWithPrefix _record
done

if [[ $ENCRYPTION == true ]]; then

    # Get passphrase
    setPassphrase PASSPHRASE "disk encryption passphrase"
    #PASSPHRASE=DEBUG

    # Encrypt partitions
    for _record_index in {1..$NUM_STORAGE_RECORDS}; do
        setActiveStorageRecordWithPrefix $_record_index _record
        if [[ ${(L)_record_fstype} == luks ]]; then
        print "Encrypting $_record_label on $_record_device_path ... "
            print -r "$PASSPHRASE" \
                | cryptsetup ${LUKS_OPTIONS[FORMAT_OPTIONS]:-} \
                  luksFormat $_record_device_path
            print -r "$PASSPHRASE" \
                | cryptsetup open ${LUKS_OPTIONS[OPEN_OPTIONS]:-} \
                  ${SSD:-${LUKS_OPTIONS[OPEN_OPTIONS,SSD]:-}} \
                  $_record_device_path $_record_label
        fi
        unsetActiveStorageRecordWithPrefix _record
    done

    # Cleanup
    unset PASSPHRASE

fi

:<< \
-------------------------------------------------------------------------------
MAKE FILESYSTEMS
-------------------------------------------------------------------------------

# FIRST PASS: isn't luks, doesn't have "child of"
# (so should be our top level physical partitions)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks && -z ${_record_child_of:-} ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled \
                                           $_record_device_path
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# SECOND PASS: isn't luks itself but is "child of" luks
# (filesystems installed on luks)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && ${(L)_record_parent_fstype:-} == luks ]]; then
        if [[ ${(L)_record_fstype} == swap  ]]; then
            eval mkswap --label $_record_label $_record_device_path
            eval swapon -L $_record_label
        else
            _mkfs_options_compiled=(${MKFS_OPTIONS[${(U)_record_fstype}]:-}
                                    ${MKFS_OPTIONS[${(U)_record_fstype},SSD]:-}
                                    ${_record_mkfs_options:-})
            eval mkfs.${(L)_record_fstype} $_mkfs_options_compiled ${_record_device_path}
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNT_OPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done

# vim: set filetype=sh :
