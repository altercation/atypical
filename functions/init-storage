#!/usr/bin/zsh

(( ${+USAGE} )) || USAGE='
-------------------------------------------------------------------------------

init-storage

part of Atypical - A Typical Arch Linux Install Script
Ethan Schoonover <es@ethanschoonover.com>

Usage:

init-storage storage-table-filename
init-storage /full/absolute/path/to/storage-table-filename
init-storage http://url/of/file/to/curl

Examples:

init-storage btrfs-simple
init-storage /root/atypical/storage/my-storage-setup
init-storage http://myserver.com/storage

(see storage subdirectory of atypical for details on format)

-------------------------------------------------------------------------------
' 

:<< \
-------------------------------------------------------------------------------
MAIN EXECUTION - run all __ functions in order after preloading rest of script
-------------------------------------------------------------------------------
(( ${(P)+${:-PRELOAD_${s::=${${0:t}//-/}}}} )) || { typeset PRELOAD_$s;
typeset -i i; alias -g "__"='__${s}_$((++i))'; . $(readlink -f $0);
eval ${(pj:; :)${(nk)functions[(I)__${s}_*]}}; exit; }

:<< \
-------------------------------------------------------------------------------
SCRIPT ENVIRONMENT & DEFAULT VALUES
-------------------------------------------------------------------------------
# script absolute path, name, and load of common script env, opts, functions
# if defined already in main atypical script, use those, otherwise redefine
(( ${+SCRIPT_ROOT} )) || { # if the script root value is undefined, proceed
    typeset -g SCRIPT_PATH SCRIPT_NAME="${${SCRIPT_PATH:=$(readlink -f $0)}:t}"
    # we use the actual atypical script root here
    typeset -g SCRIPT_ROOT="${${SCRIPT_PATH::=${SCRIPT_PATH:h}}:h}"
    typeset -g FUNC_ROOT="${SCRIPT_ROOT}/functions"
    for _fm in ${FUNC_ROOT}/environment/*; do source ${_fm}; done }

typeset -g MOUNTROOT="${MOUNTROOT:-${2:-/mnt}}"
[[ -n ${STORAGE_FILE:=${1:-}} ]] || {
    errorLog "No storage table file specified." || usage 1; }

[[ ! -f "${TMPSTOR::=$TMPDIR/storage}" ]] || {
    errorLog "Temp file collision: $TMPSTOR already exists, but shouldn't!";
    exit 1; }

__ () { :<< \
-------------------------------------------------------------------------------
Setting storage options
-------------------------------------------------------------------------------
# These will be applied generally and can be appended on a device by
# device basis in the storage table (in the storage_* pattern file)

# NOTE -- use $_record_fieldname to refer to record specific values to
# be replaced at run time (e.g. $_record_label to use the LABEL field
# value for the record which the option will be applied to).

# known filesystem types
typeset -Ag VALID
VALID[FSTYPES]="btrfs vfat exfat ext2 ext3 ext4 f2fs jfs nilfs2 ntfs reiser4 reiserfs xfs zfs"

# these MKFS[CMD,*] commands will only be used if assigned, otherwise the default
# mkfs.FILESYSTEMNAME command will be used
typeset -Ag MKFS
MKFS[CMD,BTRFS]=''
MKFS[CMD,VFAT]=''
MKFS[CMD,EXFAT]=''
MKFS[CMD,EXT2]=''
MKFS[CMD,EXT3]=''
MKFS[CMD,EXT4]=''
MKFS[CMD,F2FS]=''
MKFS[CMD,JFS]=''
MKFS[CMD,NILFS2]=''
MKFS[CMD,NTFS]=''
MKFS[CMD,REISER4]=''
MKFS[CMD,REISERFS]=''
MKFS[CMD,XFS]=''
MKFS[CMD,ZFS]=''

# mkfs default options (both common and specific to each fstype)
MKFS[OPTIONS,COMMON]=''
MKFS[OPTIONS,SSD]=''
MKFS[OPTIONS,BTRFS]='--force${ACTIVE[LABEL]:+ --label }${ACTIVE[LABEL]:-}'
MKFS[OPTIONS,BTRFS,SSD]='--metadata single' # see man mkfs.btrfs
MKFS[OPTIONS,VFAT]='-F32${ACTIVE[LABEL]:+ -n }${ACTIVE[LABEL]:-}'
MKFS[OPTIONS,VFAT,SSD]=''
MKFS[OPTIONS,EXFAT]=''
MKFS[OPTIONS,EXT2]=''
MKFS[OPTIONS,EXT3]=''
MKFS[OPTIONS,EXT4]=''
MKFS[OPTIONS,F2FS]=''
MKFS[OPTIONS,JFS]=''
MKFS[OPTIONS,NILFS2]=''
MKFS[OPTIONS,NTFS]=''
MKFS[OPTIONS,REISER4]=''
MKFS[OPTIONS,REISERFS]=''
MKFS[OPTIONS,XFS]=''
MKFS[OPTIONS,ZFS]=''

# mount default options (both common and specific to each fstype)
typeset -Ag MOUNTOPTIONS
MOUNTOPTIONS[COMMON]='rw'
MOUNTOPTIONS[SSD]='noatime'
MOUNTOPTIONS[BTRFS]='compress=lzo,space_cache,autodefrag,inode_cache,'
MOUNTOPTIONS[BTRFS,SSD]='ssd,discard_space'
MOUNTOPTIONS[VFAT]='-F32${ACTIVE[LABEL]:+ -n }${ACTIVE[LABEL]:-}'
MOUNTOPTIONS[VFAT,SSD]=''
MOUNTOPTIONS[EXFAT]=''
MOUNTOPTIONS[EXT2]=''
MOUNTOPTIONS[EXT3]=''
MOUNTOPTIONS[EXT4]=''
MOUNTOPTIONS[F2FS]=''
MOUNTOPTIONS[JFS]=''
MOUNTOPTIONS[NILFS2]=''
MOUNTOPTIONS[NTFS]=''
MOUNTOPTIONS[REISER4]=''
MOUNTOPTIONS[REISERFS]=''
MOUNTOPTIONS[XFS]=''
MOUNTOPTIONS[ZFS]=''

# luks default options (format, open, and ssd specific)
# Note that --force-password allows weak passphrases (for testing only)
typeset -A LUKS
LUKS[FORMAT]='--force-password'
LUKS[OPEN]=''
LUKS[OPEN,SSD]='--allow-discards'

}; __ () { :""<< \
-------------------------------------------------------------------------------
Accessing atypical storage table file
-------------------------------------------------------------------------------
simPrint "\# Storage initialization\n"
# source remote URI or create absolute filepath
if [[ "$STORAGE_FILE" =~ "(http|ftp)s?:.*" ]]
then
    { curl -#L $STORAGE_FILE -o $TMPSTOR } ioLog \
    && { successLog "Retrieved remote storage table file.";
         STORAGE_FILE="$TMPSTOR"; } \
    || errorLog "Failed to retrieve remote storage table file. Check URL:" \
                "$STORAGE_FILE";
fi

# create absolute path if storage value is simple filename or relative path
# finally confirming that storage path exists
if [[ "${STORAGE_FILE:0:1}" != "/" ]]
then
    if [[ -n "${CUSTOM_ROOT:-}" ]] \
    && [[ -f "${STORAGE_PATH::=$CUSTOM_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found custom storage table file $STORAGE_FILE." || \
    elif [[ -f "${STORAGE_PATH::=$SCRIPT_ROOT/storage/$STORAGE_FILE}" ]]
    then
        # found custom rooted storage file
        successLog "Found storage table file $STORAGE_FILE." || \
        debugLog "Used storage path: $STORAGE_PATH"
    else
        errorLog "Could not find storage table file named $STORAGE_FILE." \
            "\nCheck your storage subdirectory and naming." \
            "\nLast checked path: $STORAGE_PATH"
    fi
    STORAGE_FILE="$STORAGE_PATH"
elif [[ ! -f "$STORAGE_FILE" ]]
then
    errorLog "Could not find storage table file at path $STORAGE_FILE."
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Processing storage table values
-------------------------------------------------------------------------------
# The valid options (boolean and scalar separate) for storage items.
# Not all options are valid for all types, but this is at least a basic
# sanity check. Used in the convertStorageFileToArray function, listed
# here as this is the one stop location for adding/removing/renaming.
typeset -ga STOROPTS_SCAL STOROPTS_BOOL
STOROPTS_BOOL=(bootable noclobber ssd)
STOROPTS_SCAL=(devpath fstype label code mkfsoptions mountoptions mountpoint size type)

# a little too dependent on state, but it's not easy to functionally
# pass associative arrays around so this will write out to the
# global STORAGE array. This could be passed at least as an explicit
# --output argument (i.e. the name of the array) but indirect references
# to associative array values are ridiculous looking in zsh.
typeset -gA STORAGE
simPrint "\n# Source storage file equivalent to the following.
# For reference only, unused in this sim file.
:<< \\\\
'SOURCE\'"
convertStorageFileToArray --input $STORAGE_FILE \
    && successLog "Storage file successfully converted for processing." \
    || errorLog "Failed to converted storage file for processing."
simPrint "SOURCE\n"

}; __ () { :""<< \
-------------------------------------------------------------------------------
Identifying installation drive(s)
-------------------------------------------------------------------------------
# Uses either the preset --devpath value for drives from the storage file or
# interactively selects the drive

_drives=($(getStorageItemIndexesOfType drive))
_unmounted_drives="$(getUnmountedDrives)"
for _drive in $_drives
do
    debugLog "Checking drive $_drive"
    if [[ -z "${STORAGE[$_drive,DEVPATH]:-}" ]]
    then
        _msg="Please select a drive for installation"
        alertLog "\n\n$_msg"
        if (( ${#_drives} > 1 )); then
            printLog "(drive $_drive of ${#_drives})\n"
        else
            printLog "(single drive installation)\n"
        fi
        selectDrive DRIVEPATH
        STORAGE[$_drive,DEVPATH]="${DRIVEPATH:-}"
        [[ -z "$SSD" ]] || {
        print "YES IS SSD" # debug DEBUG xxx
        STORAGE[$_drive,SSD]="true"
    }
    else
        # set a flag so that we know a drive device path has been picked using
        # a value from the storage file... we want to confirm again if this is
        # the case...
        valueIsInList --value ${STORAGE[$_drive,DEVPATH]} \
                      --list "$_unmounted_drives" || {
        $(${TEST:-false} && print "printLog" || print "errorLog") \
                "${STORAGE[$_drive,DEVPATH]} is specified explicitly in"\
                "storage definition file but is currently\nmounted or"\
                "inaccessible." || exit 1
            }
        STORAGE[FILEPICKEDPATH]=true
    fi
done

# if any of the drive paths were set directly from the storage file, confirm
# before proceeding (no auto erasure)
if (( ${+STORAGE[FILEPICKEDPATH]} ))
then
    (( ${#$(getStorageItemIndexesOfType drive)} > 1 )) && s="s" || s=""
    # (( ${#_drives} > 1 )) && s="s" || s=""
    ${SIM:-false} || alertLog "IMPORTANT - DATA WILL BE ERASED!"
    printLog "Installation will occur to the following device$s:\n"
    for _drive in $(getStorageItemIndexesOfType drive)
    do
        printLog "DRIVE $_drive device path: ${STORAGE[$_drive,DEVPATH]}"
    done
    ${FORCE:-false} || {
        queryLog "\nEnter'y' to install to drive$s listed, 'q' to quit: (y/q) "
        read -k CONFIRM ||:; [[ ${(L)CONFIRM} == "y" ]] || {
        printLog "\n\nUser selected exit.\n"; exit 0 }
        }
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Assembling device paths on target drive(s)
-------------------------------------------------------------------------------
# following function assigns valid device paths to all STORAGE items
makeDevPaths \
    && successLog "Assembled device paths successfully." \
    || errorLog "Failed to assemble device paths."

debugLog "\nSTORAGE ARRAY VALUES:\n"
for _childkey in ${(ovps: :)STORAGE[(I)*CHILDREN]}; do
    for _key in ${(ok)STORAGE[(I)$_childkey,[^[:digit:]]*]}; do
        debugLog "$_key: ${STORAGE[$_key]}"
    done
done

}; __ () { :""<< \
-------------------------------------------------------------------------------
DESTRUCTION FOLLOWS!
If in test mode and not simulating, close encrypted volumes, shut down swap and
unmount known mounts
-------------------------------------------------------------------------------
${SIM:-false} || :""""<<< "INSTALLATION BEGINNING... DATA WILL BE ERASED!"
if ${TEST:-false} && ! ${SIM:-false}; then
    printLog "\nTEST MODE: Closing known encrypted and swap items"
    _encryption=($(getStorageItemIndexesOfType encryption))
    for _encrypted_item in ${_encryption}; do
        activateRecord $_encrypted_item
        ${SIM:-false} || cryptsetup close ${ACTIVE[LABEL]} || :
    done
    _swap=($(getStorageItemIndexesOfType swap))
    for _swap_item in ${_swap}; do
        activateRecord $_encrypted_item
        if (( ${+ACTIVE[LABEL]} )); then
            ${SIM:-false} || swapoff -L ${ACTIVE[LABEL]}
        else
            typeset _uuid=$(getUUIDForDevpath ${ACTIVE[DEVPATH]})
            ${SIM:-false} || swapoff -U $_uuid
        fi
    done
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Erasing/preparing target drive(s)
-------------------------------------------------------------------------------
for _drive in $(getStorageItemIndexesOfType drive); do
    activateRecord $_drive
    if (( ${+ACTIVE[NOCLOBBER]} )); then
        alertLog "\nNoclobber option set on drive $_drive !"
        printLog "\nNoclobber prevents all changes to a drive. This is likely"\
                 "not what you intended. \nnoclobber should be used on "\
                 "existing partitions or filesystems)\n"
        exit 1
    else
        alertLog "\nPreparing to erase drive $_drive... ${_SIM}"
        ${TEST:-false} && _c=0 || _c=5
        ${SIM:-false} || countdownMsg $_c "Erasing drive ${ACTIVE[DEVPATH]}"
        evalSim  sgdisk --zap-all ${ACTIVE[DEVPATH]} # erase everything!
        evalSim  sgdisk --clear ${ACTIVE[DEVPATH]}   # create new gpt structure
        ${SIM:-false} || successLog "Drive ${ACTIVE[DEVPATH]} erased!"
    fi
done

}; __ () { :""<< \
-------------------------------------------------------------------------------
Processing partitions
-------------------------------------------------------------------------------
_partitions=($(getStorageItemIndexesOfType partition))
if [[ -n "${_partitions}" ]];
then

    # check for bootable option or, if single partition, make it bootable
    # TODO: there may be edge cases where making a single partition bootable
    # is not desirable.
    if (( ${#_partitions} > 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        errorLog "At least one partition must have the --bootable option in" \
            "the storage item\ndefinition file"
    elif (( ${#_partitions} == 1 )) \
        && [[ -z "${(k)STORAGE[(I)*BOOTABLE]}" ]]; then
        # single partition, set as bootable
        STORAGE[${_partitions},BOOTABLE]=true
    fi

    typeset -a _sgdisk_cmd
    for _drive in $(getStorageItemIndexesOfType drive); do
        activateRecord $_drive
        _drive_devpath=${ACTIVE[DEVPATH]}
        for _partition in \
            $(getStorageItemIndexesOfTypeForParent partition $_drive)
        do
            activateRecord $_partition
            printLog "Preparing formatting command for ${ACTIVE[DEVPATH]}"
            _id=${ACTIVE[DEVPATH][-1]}
            if [[ ${(L)ACTIVE[SIZE]} =~ "^max" ]]; then
                _sgdisk_cmd+=("--largest-new=${_id}")
            elif [[ ${(L)ACTIVE[SIZE]} =~ "ram" ]]; then
                _ram=$(print "$(( $(print ${$(cat /proc/meminfo \
                | grep -i memtotal)[2]}) / 1000000 ))G")
                _sgdisk_cmd+=("--new=${_id}:0:+$_ram")
            else
                _sgdisk_cmd+=("--new=${_id}:0:+${ACTIVE[SIZE]}")
            fi
            if [[ -n "${(L)ACTIVE[BOOTABLE]:-}" ]]; then
                _sgdisk_cmd+=("--attributes=${_id}:set:0")
            fi
            #[[ -z "${ACTIVE[CODE]:-}" ]] || \
            #    _sgdisk_cmd+=("--typecode=${_id}:${ACTIVE[CODE]}")
            _sgdisk_cmd+=(${ACTIVE[CODE]:+--typecode=${_id}:${ACTIVE[CODE]}})
            _sgdisk_cmd+=(${ACTIVE[LABEL]:+--change-name=${_id}:${(q-)ACTIVE[LABEL]}})
        done
        _sgdisk_cmd+=($_drive_devpath)
        #evalSim "print 'Partitioning...' && sgdisk $_sgdisk_cmd && print 'Partitions created successfully' || { print 'Partition creation failed'; exit 1; }"
        evalSim "sgdisk $_sgdisk_cmd"
    done
else
    # TODO: can add in an fstype validity check here and remove warning
    alertLog "No partitions listed as children of drives! Ensure you have" \
        "specified a\nfilesystem type that can be initialized directly to a" \
        "drive without a partition.\nPROCEEDING..."
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Encrypting storage
-------------------------------------------------------------------------------
_encryption=($(getStorageItemIndexesOfType encryption))
if [[ -n "$_encryption" ]]; then
    # Get passphrase (or use test mode passphrase)
    ${TEST:-false} && PASSPHRASE="testpassphrase" || \
        setPassphrase PASSPHRASE "disk encryption passphrase"
    # Encrypt partitions
    for _encrypted_item in ${_encryption}; do
        activateRecord $_encrypted_item
        printLog "Encrypting ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}..."
        if itemIsInSSD $_encrypted_item; then
            _ssd="${LUKS[OPEN,SSD]:-}"
        else
            _ssd=""
        fi
        typeset -a _luks_format _luks_open
        _luks_format=(
            print -r "$PASSPHRASE" "| cryptsetup ${LUKS[FORMAT]:-}"
            luksFormat ${STORAGE[${ACTIVE[PARENT]},DEVPATH]}
            )
        _luks_open=(
            print -r "$PASSPHRASE" "| cryptsetup open ${LUKS[OPEN]:-}"
            ${STORAGE[${_encrypted_item:0,1},SSD]:+${LUKS[OPEN,SSD]:-}}
            ${_ssd}
            ${STORAGE[${ACTIVE[PARENT]},DEVPATH]} ${ACTIVE[LABEL]}
            )
        evalSim ${_luks_format}
        evalSim ${_luks_open}
    done
    unset PASSPHRASE
else
    successLog "No encrypted storage items found; skipping encryption."
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Activating swap
-------------------------------------------------------------------------------
_swap=($(getStorageItemIndexesOfType swap))
if (( ${#_swap} > 1 )); then
    errorLog "Multiple swap partitions listed; there can be only one."
    exit 1
elif (( ${#_swap} == 1 )); then
    activateRecord ${_swap}
    if itemIsInSSD $_swap; then
        _ssd="--discard"
    else
        _ssd=""
    fi
    if (( ${+ACTIVE[LABEL]} )); then
        evalSim mkswap -L ${ACTIVE[LABEL]} ${ACTIVE[DEVPATH]}
        evalSim swapon -L ${ACTIVE[LABEL]:-} ${_ssd}
    else
        typeset _uuid=$(getUUIDForDevpath ${ACTIVE[DEVPATH]})
        evalSim mkswap -U $_uuid ${ACTIVE[DEVPATH]}
        evalSim swapon -U $_uuid ${ACTIVE[LABEL]:-} ${_ssd}
    fi
    (( $? == 0 )) && successLog "Successfully activated Swap" || {
        errorLog "Failed to create/activate swap"; exit 1; }
fi

}; __ () { :""<< \
-------------------------------------------------------------------------------
Initializing filesystems
-------------------------------------------------------------------------------
for _filesystem in $(getStorageItemIndexesOfType filesystem); do
    activateRecord $_filesystem
    printLog "Creating ${ACTIVE[FSTYPE]} filesystem in ${ACTIVE[DEVPATH]}..."
    itemIsInSSD $_filesystem \
        && _ssd="${MKFS[${(U)ACTIVE[FSTYPE]},SSD]:-}" || _ssd=""
    typeset -a _mkfs_options
    _mkfs_options=(
        ${MKFS[OPTIONS,${(U)ACTIVE[FSTYPE]}]:-}
        ${_ssd}
        ${ACTIVE[MKFSOPTIONS]:-}
        )
        _mkfscmd=${MKFS[CMD,${(U)ACTIVE[FSTYPE]}]:-mkfs.${(L)ACTIVE[FSTYPE]}}
        evalSim $_mkfscmd ${(e)_mkfs_options} ${ACTIVE[DEVPATH]}
done

}; __ () { :""<< \
-------------------------------------------------------------------------------
Mounting filesystems and initializing subvolumes
-------------------------------------------------------------------------------
# create ordered list of mountpoints so we mount them in the right order
typeset -A _mountpoint_list
typeset -T _MOUNTOPTIONS_CSV _mountoptions ,
_mountpoint_list=(${(kv)STORAGE[(I)*,MOUNTPOINT]})
for _mountpoint in ${(vo)_mountpoint_list}
do
    activateRecord ${(k)STORAGE[(r)$_mountpoint]%,MOUNTPOINT}
    if [[ "${ACTIVE[TYPE]}" == "subvolume" ]]
    then
        :
        # make a subvolume, etc.
        _mountpoint="${MOUNTROOT%/}/${ACTIVE[MOUNTPOINT]#/}"
        evalSim "btrfs subvolume create ${(q-)_mountpoint%/}"
    elif [[ "${ACTIVE[TYPE]}" == "filesystem" ]]
    then
        :
        # mount an existing filesystem
        _mountoptions=()
        _mountoptions+=(${MOUNTOPTIONS[COMMON]:-})
        _mountoptions+=("${MOUNTOPTIONS[${(U)ACTIVE[FSTYPE]}]:-}")
        itemIsInSSD $_filesystem && {
            _mountoptions+=(${MOUNTOPTIONS[SSD]:-})
            _mountoptions+=(${MOUNTOPTIONS[${(U)ACTIVE[FSTYPE]},SSD]:-})
            } || :
        _mountoptions+=(${ACTIVE[MOUNTOPTIONS]:-})
        _mountcmd="mount ${DEBUG:+ --verbose }x-mount.mkdir"
        _mountpoint="${MOUNTROOT%/}/${ACTIVE[MOUNTPOINT]#/}"
        evalSim "$_mountcmd -o"\
                 "${_MOUNTOPTIONS_CSV//,,/,}"\
                 "${ACTIVE[DEVPATH]} ${(q-)_mountpoint%/}"
    else
        errorLog "\nStorage item type ${ACTIVE[TYPE]} should not have a" \
                 "mountpoint as listed in the storage definition file." || :
        printLog "Ignoring this mountpoint ($_mountpoint)!"
    fi
done

:<< 'EOF'
# THIRD PASS: isn't luks, is a "child of" but NOT of luks, so probably special case of btrfs subvolumes (or LVM if I choose to implement it)
for _record_index in {1..$NUM_STORAGE_RECORDS}; do
    setActiveStorageRecordWithPrefix $_record_index _record
    if [[ ${(L)_record_fstype} != luks \
       && -n ${_record_child_of:-} \
       && ${(L)_record_parent_fstype} != luks ]]; then
        if [[ ${(L)_record_fstype} == btrfs \
           && ${(L)_record_parent_fstype} == btrfs ]]; then
            # a btrfs subvolume
            mount $_record_parent_device_path $MOUNT_ROOT
            if [[ -n ${_record_mount_point#/} \
               && -n ${_record_parent_mount_point:-} ]]; then
               # create the subvolume as a subdirectory of a
               # parent volume that will itself be mounted
                dirname=${_record_mount_point:t}
                dirpath=${_record_mount_point:h}
                _mount_point=${MOUNT_ROOT%/}/${_record_mount_point#/}
                mkdir -p ${_mount_point:h}
                eval btrfs subvolume create ${_mount_point%/}/$_record_label 
            else
                # create the subvolumes as stand alone "peers"
                # on a parent volume that will not itself be mounted
                #eval "btrfs subvolume create ${MOUNT_ROOT%/}/$_record_label"
                btrfs subvolume create "${MOUNT_ROOT%/}/$_record_label"
                eval "STORAGE_RECORDS[${_record_index},MOUNT_OPTIONS]=\"${_record_mount_options:-}${_record_mount_options:+,}subvol=$_record_label\""
                eval "STORAGE_RECORDS[${_record_index},MOUNTED_BTRFS_SUBVOL]=true"
            fi
            umount $MOUNT_ROOT
        else
            # some case I haven't built for yet
            print -n "Filesystem of type $_FSTYPE set as child of parent "
            print "device with filesystem of type $_record_fstype: "
            print "No procedure set for this condition. Exiting."
            exit 1
        fi
    fi
    unsetActiveStorageRecordWithPrefix _record
done

# Mount
for _mount_point in $MOUNT_POINTS; do

    _record_index=$(lookupRecordByFieldValue \
                    MOUNT_POINT "$_mount_point" STORAGE_RECORDS)

    setActiveStorageRecordWithPrefix $_record_index _record

    _mount_options_compiled=""

    # build mount option list:
    # --------------------------------------
    # add common and record specific options
    addToCommaList _mount_options_compiled \
                   ${_record_mount_options:-} \
                   ${MOUNT_OPTIONS[COMMON]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype}]:-}

    # add ssd common and record specific options
    [[ -n ${SSD:-} ]] && \
    addToCommaList _mount_options_compiled \
                   ${MOUNT_OPTIONS[SSD]:-} \
                   ${MOUNT_OPTIONS[${(U)_record_fstype},SSD]:-} || :

    # add luks specific options if there is a luks ancestor
    # (if we are in an encrypted container)
    storageGetLuksAncestorIndex $_record_index &>/dev/null && \
    addToCommaList _mount_options_compiled
                   ${MOUNTOPTIONS[LUKS]:-} || :

    # build mount point:
    # --------------------------------------
    # take table mount point and combine with system install mount point
    _mount_point_compiled=${MOUNT_ROOT%/}/${_record_mount_point#/}

    # handle possible btrfs subvolume specific issues
    if [[ -n ${_record_parent_mount_point:-} ]]; then
        _parent_mount_point=${MOUNT_ROOT%/}/${_record_parent_mount_point#/}
        if findmnt $_parent_mount_point &>/dev/null; then
            # if parent btrfs volume is mounted, the subvolumes
            # are already present... don't need to do anything here?
            #mkdir -p ${_mount_point_compiled}
            :
        else
            print -n "Parent device not mounted but required for mounting of "
            print "filesystem (likely a btrfs subvolume)."
            print "    Parent: $_record_parent_label"
            print "    Attempting to mount: $_record_label"
            exit
        fi
    fi

    # label based on btrfs subvolume or not
    [[ -n ${_record_mounted_btrfs_subvol:-} ]] \
    && _label=$_record_parent_label \
    || _label=$_record_label

    # prepare and execute mount
    mkdir -p ${_mount_point_compiled}
    eval "mount -o $_mount_options_compiled \
                   LABEL=$_label \
                   $_mount_point_compiled"

    unsetActiveStorageRecordWithPrefix _record

done
EOF
}

:<< \
-------------------------------------------------------------------------------
HELPER FUNCTIONS
-------------------------------------------------------------------------------

# only these storage types allowed
valueIsInList () {
    typeset -A _opts
    zparseopts -D -E -A _opts -value: -list:
    _value="${${_opts[--value]:-}#=}"
    _list=(${(ps: :)${_opts[--list]:-}})
    (( ${_list[(i)$_value]} <= ${#_list} ))
    }

typeIsValidStorageType () {
    typeset _type="$1"
    typeset -A VALID
    VALID=(TYPES "drive partition logical encryption filesystem subvolume swap")
    [[ ${(L)_type} =~ "dis" ]] && _extra="\nDid you mean to use \'drive\'?" || :
    valueIsInList --value $_type --list "${VALID[TYPES]}" && return 0 || \
        errorLog "\'$_type\' is not a valid storage type.${_extra:-}"
    }

typeIsValidChildOf () {
    typeset _type="$1" _parent_type=$2
    typeset -A VALID
    VALID=(
        TYPES,CHILDREN,DRIVE "partition logical encryption filesystem"
        TYPES,CHILDREN,PARTITION "logical encryption filesystem swap"
        TYPES,CHILDREN,ENCRYPTION "logical filesystem swap"
        TYPES,CHILDREN,FILESYSTEM "subvolume"
        TYPES,CHILDREN,SWAP ""
        )
        valueIsInList --value $_type \
            --list "${VALID[TYPES,CHILDREN,${(U)_parent_type}]}" || {
            errorLog "\'$_type\' is not a valid child type for $_parent_type."
            exit 1
            }
    }

itemHasRequiredOptions () {
    typeset _item_type="${(U)1}"; shift
    typeset _item_options_assigned="$@"
    typeset -A REQUIRED
    REQUIRED=(
        DRIVE ""
        PARTITION "size"
        ENCRYPTION "label"
        FILESYSTEM "fstype mountpoint"
        SUBVOLUME "mountpoint"
        SWAP ""
        )
    for _item_req in ${(ps: :)REQUIRED[$_item_type]}
    do
        valueIsInList --value $_item_req --list "$_item_options_assigned" || \
            errorLog "\'$_type\' requires the --$_item_req option"\
                     "in its storage file entry."
    done
    }

convertStorageFileToArray () {
    # _opts contains the arguments passed to this function

    typeset -A _opts
    zparseopts -D -E -A _opts -input: -output:
    _inputfilepath="${${_opts[--input]:-}#=}"
    _outputarrayname="${${_opts[--output]:-}#=}"

    # initialization
    #[[ -n "$_inputfilepath" && -n "$_outputarrayname" ]] \
    #    || errorLog "$0 requires both a filepath and output arrayname."

    unset PAYLOAD
    typeset -ag STORAGE_CMDS $_outputarrayname
    typeset -a STORAGE_FILE_RAW_DATA
    typeset -a STORAGE_FILE_SCRUBBED_DATA
    typeset -Ag CHILDREN

    # read storage file into array
    STORAGE_FILE_RAW_DATA=(${(f)"$(<$_inputfilepath)"})

    # strip comments (full or partial)
    # merge escaped newlines into single lines
    for _line in "${(@)STORAGE_FILE_RAW_DATA}"; do

        # if this line isn't blank or a comment, continue to process
        if [[ -n "${_line::=${_line//\#*}}" \
            && ! "$_line" =~ "^[[:space:]]*$" ]]; then

            # if this line ends in an escaped newline, prep to merge with next
            if [[ "${_line[-1]}" == \\ ]]; then
                # set as previous line (and append if we have escaped
                # newlines on multiple sequential lines)
                _prev_line="${_prev_line:-}$_line[1,-2]"

            # otherwise assign line to payload (merging with any prev line)
            else

                _line="${_prev_line:-}$_line"
                # record line in sim file
                simPrint "$_line"
                _indent="${#${_line}%%[^[:space:]]*}"

                # if this is the first line, initialize the payload and
                # check that the first line is of type drive. if not,
                # prepend a "drive" line (assume implied drive) and add a
                # global indent value
                (( ${+PAYLOAD} )) || {
                    typeset -ag PAYLOAD
                    [[ "${${(ps: :)_line}[(w)1]}" == "drive" ]] && {
                        typeset -i _base_indent=$_indent
                        PAYLOAD=()
                    } || {
                        typeset -i _extra_indent=1
                        typeset -i _base_indent=0
                        _payload="--type drive "
                        _payload+="--item_indent 0"
                        PAYLOAD=("$_payload")
                        }
                    }

                _payload="--type ${_line:${_indent}:${#_line}} "
                _payload+="--item_indent $(( $_indent + ${_extra_indent:-0} ))"
                PAYLOAD+=("$_payload")
                _prev_line=""
            fi
        fi
    done

    debugLog "\nPAYLOAD IS CURRENTLY:"
    for _pline in "${(@)PAYLOAD}"; do debugLog "$_pline"; done
    debugLog

    # loop through payload and convert, normalizing to command argument
    # format and performing basic compliance checks
    initializeStorageTreeValues  --base_indent $_base_indent

}

initializeStorageTreeValues () {
# uses global state PAYLOAD, yuck. should change this to be a passed
# scalar value or at the very least a variable reference. Also, should
# pass the output (STORAGE) array name as a reference, at least. TODO
typeset _funcopt_values_as_called="$*"
typeset -i _item_index=0
typeset -a _funcopts
_funcopts=(base_indent item_indent parent_index section_indent outputarrayname)

while (( ${#PAYLOAD} )); do
    eval set -- "$_funcopt_values_as_called ${_head::=${PAYLOAD[1]:-}}"
    _options_assigned=""
    
    for _opt in $STOROPTS_BOOL; do
        eval "zparseopts -E -$_opt=_$_opt"
        eval '_optvalue="${_'$_opt'[1]:-}"'
        [[ -z "$_optvalue" ]] || {
            eval $_opt'[1]=true';
            _options_assigned+=" $_opt";
            }
    done
    for _opt in $_funcopts $STOROPTS_SCAL; do
        eval "zparseopts -E -$_opt:=_$_opt"
        eval _$_opt'[1]=()'
        eval '[[ -z "${_'$_opt'[1]:-}" ]] || {
            _'$_opt'[1]="${_'$_opt'[1]#=}"
            _options_assigned+=" $_opt"
            }'
    done

    # item is a peer of the current section
    if (( $_item_indent == ${_section_indent:-$_base_indent} ))
    then
        _item_index+=1
        _parent_index_d="${_parent_index:-}${_parent_index:+,}"
        _full_index="${_parent_index_d}${_item_index}"

        # check that the storage item is not a toaster
        typeIsValidStorageType $_type || {
            errorLog "Exiting due to invalid storage type."
            exit 1
            }

        # make sure we have all required options
        itemHasRequiredOptions "$_type" "$_options_assigned" || {
            errorLog "Exiting due to missing required storage item option."
            exit 1
            }

        _parent_type="${STORAGE[${_parent_index:-},TYPE]:-}"
        if [[ -n ${_parent_type} ]]; then
            # has a parent, check it, erroring out if not valid
            typeIsValidChildOf $_type $_parent_type
        elif [[ "$_type" != "drive" ]]; then
            # no parent, make sure it is of type drive
            # if not, assume implied drive and insert a
            # plain drive entry above it? TODO
            errorLog "Root devices must be type \"drive\""\
                     "(not \"$_type\")."
        fi

        # STORAGE[${_parent_index_d}CHILDTYPES]+=" $_type"
        STORAGE[${_parent_index_d}CHILDREN]+=" $_full_index"

        # $DEBUG && STORAGE[${_full_index},ARGS]="$@ $_head"

        [[ -z ${_parent_index} ]] || \
            STORAGE[${_full_index},PARENT]+="$_parent_index"

        for _opt in $STOROPTS_BOOL $STOROPTS_SCAL; do
            #eval '_optvalue="${_'$_opt'}"'
            eval '_optvalue="${_'$_opt':-}"'
            [[ -z "${_optvalue}" ]] || \
                STORAGE[${_full_index},${(U)_opt}]+="$_optvalue"
        done

        # trim payload for next go round
        PAYLOAD[1]=()

    # item is a child of the current section, so recurse
    elif (( $_item_indent > ${_section_indent:-$_base_indent} ))
    then
        _full_index="${_parent_index:-}${_parent_index:+,}${_item_index}"
        $0  --base_indent "$_base_indent" \
            --section_indent "$_item_indent" \
            --parent_index "$_full_index"

    elif (( $_item_indent < ${_section_indent:-$_base_indent} ))
    then

        # payload head is superior to current level, so return from
        # recursive call until we get back to a peer level
        return 0

    fi
done
}

getUnmountedDrives () {
    typeset -a drives
    drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
    for drive in $drives; do
        { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $drive)" ]] \
          || mount | grep $drive; } && drives=("${(@)drives:#$drive}") || :
    done
    print "$drives"
}
selectDrive () {
    varname=$1
    typeset -a drives
    typeset -g SSD
    drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
    debugLog "Full list of drives: $drives"

    # check if device or child has an existing mountpoint and remove from drives
    # array if so
    for drive in $drives; do
        { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $drive)" ]] \
          || mount | grep $drive; } && drives=("${(@)drives:#$drive}") || :
    done
    debugLog "List of drives with no mountpoint: $drives"

    userQuit () { printLog "\nUser selected quit."; exit; }

    # User selects drive for install
    typeset CONFIRM="" SELECTED=""
    typeset -i i=0
    while [[ ! $CONFIRM =~ [Yy] ]]; do

        # list drives
        printLog "Available unmounted drives for installation:\n"
        for drive in $drives; do
            alertLog "[$(( i += 1))] $drive ($(/usr/bin/lsblk -dno SIZE $drive))"
        done

        # Pick drive or quit
        queryLog "\nPlease enter the number of the drive you wish to install to," \
                 "or 'q' to quit: (1$((($i > 1)) && queryLog "-$i")/q) "
        while [[ -z $SELECTED || ! $SELECTED =~ [1-$i] && ! ${(L)SELECTED} == q ]]
        do
            queryLog "\b \b"
            read -k 1 SELECTED || : # read returns an error code at EOF; ignore it
        done
        [[ $SELECTED != "q" ]] || userQuit

        # Identify as SSD or standard
        queryLog "\n\nIs $drives[$SELECTED] an SSD? (y/N):"
        read -k SSD || :; [[ ${(L)SSD} == y ]] && SSD="" || unset SSD; echo

        # Summarize and confirm
        alertLog "\nYou have selected $drives[$SELECTED] for"\
                 "COMPLETE ERASURE, and identified it as ${SSD-NOT }an SSD."
        queryLog "\nEnter'y' to erase, 'n' to make changes, or 'q' to quit: (y/N/q) "
        read -k CONFIRM ||:; [[ ${(L)CONFIRM} != "q" ]] || userQuit
    done

    eval "typeset -g $varname"
    eval $varname'=$drives[$SELECTED]'

    }

makeDevPaths () {

    typeset _parent_index="${1:-}"
    typeset _parent_index_d="${_parent_index:-}${_parent_index:+,}"
    typeset _full_index

    for _full_index in ${(ps: :)STORAGE[${_parent_index_d}CHILDREN]:-}; do

        typeset _item_type=${STORAGE[${_full_index},TYPE]}
        typeset _parent_devpath=${STORAGE[${_parent_index_d}DEVPATH]:-}
        typeset _devpath=${STORAGE[${_full_index},DEVPATH]:-}
        typeset _item_label=${STORAGE[${_full_index},LABEL]:-}

        # if it hasn't already been set
        if [[ -z "$_devpath" ]]; then

            # partitions
            if [[ "$_item_type" == "partition" ]]; then
                _devpath=${_parent_devpath}${_full_index##*,}

            # encryption
            elif [[ "$_item_type" == "encryption" ]]; then
                _devpath=/dev/mapper/
                [[ -n ${STORAGE[${_full_index},LABEL]:-} ]] \
                    && _devpath+=${STORAGE[${_full_index},LABEL]:-// /_} \
                    || _devpath+=${STORAGE[${_parent_index},DEVPATH]//\//_}

            # swap
            elif [[ "$_item_type" == "swap" ]]; then
                _devpath=$_parent_devpath

            # filesystem
            elif [[ "$_item_type" == "filesystem" ]]; then
                _devpath=$_parent_devpath

            # filesystem
            elif [[ "$_item_type" == "subvolume" ]]; then
                _devpath=$_parent_devpath

            fi
            STORAGE[${_full_index},DEVPATH]=${_devpath}

        fi

        # recursively handle children
        makeDevPaths ${_full_index}

    done
    }

getStorageItemIndexesOfType () {
    typeset -A _results; _results=(${(kv)STORAGE[(I)*TYPE]})
    print ${(@ok)_results[(R)$1]%,TYPE}
    }

getStorageItemIndexesOfTypeForParent () {
    typeset -A _results; _results=(${(kv)STORAGE[(I)$2,?,TYPE]})
    print ${(@ok)_results[(R)$1]%,TYPE}
    }

activateRecord () {
    unset ACTIVE; typeset -Ag ACTIVE
    for _key in "${(@k)STORAGE[(I)$1,[^[:digit:]]*]}"; do
        ACTIVE[${_key#$1,}]="${STORAGE[$_key]}"
    done
}

getUUIDForDevpath () {
    lsblk -no UUID $1
}

itemIsInSSD () {
    (( ${+STORAGE[${(ps:,:)1[1]},SSD]} ))
}

countdown () {
    for i in {$1..1}; do print -n "$i \b" ;sleep 1; print -n "${i//?/\b}"; done
}

countdownMsg () {
    justLog "$2:"
    print -n "$2"
    for i in {$1..1}; do _count=" in $i seconds"; print -n "$_count \b" ;sleep 1; print -n "${_count//?/\b}"; done
    #print ":${_count//?/\b}:"
    print "${_count//?/ }${_count//?/\b}:"
}

setPassphrase() {
    returnvar=$1
    typeset -g $returnvar
    typeset passphrase="" confirmation=""
    prompt="${2:-passphrase}"
    while [[ -z "$passphrase" ]]; do
        print -n " Enter $prompt   : "
        read -rs passphrase
        print
        print -n " Confirm $prompt : "
        read -rs confirmation
        print
        #print; read -rs "passphrase?Enter $prompt : "
        #echo "\n\n"; read -rs "confirmation?Confirm $prompt    : "
        #echo "\n\n"
        if [[ "$passphrase" != "$confirmation" ]]; then
        print "\nInput does not match!"
        passphrase="" confirmation=""
        fi
    done
    #print -rn "$passphrase"
    typeset -g $returnvar="$passphrase"
    unset passphrase confirmation
}

# Following is reserved for future refactoring
# The storage item tree is really just a recursive set of patterns with defined
# relationships and qualities which can be further abstracted out of the program
# logic and into pattern / relationship definitions.
:<< 'REFERENCE'
typeset -Ag PATTERN
PATTERN[VALID,OPTIONS,BOOLEAN]="bootable noclobber ssd"
PATTERN[VALID,OPTIONS,SCALAR]="devpath fstype label code mkfsoptions mountoptions mountpoint size type"
PATTERN[VALID,OPTIONS]+='${(e)PATTERN[(I)VALID,OPTIONS,*]}'

typeset -Ag VALIDITY
VALIDITY[PARENT,TYPE,,TYPE]="drive"
VALIDITY[PARENT,TYPE,DRIVE,TYPE]="partition logical encryption filesystem"
VALIDITY[PARENT,TYPE,PARTITION,TYPE]="logical encryption filesystem swap"
VALIDITY[PARENT,PARENT,TYPE,ENCRYPTION,TYPE]="logical filesystem swap"
VALIDITY[PARENT,TYPE,FILESYSTEM,TYPE]="subvolume"
VALIDITY[PARENT,TYPE,SWAP,TYPE]=""
VALIDITY[PARENT,FSTYPE,BTRFS,TYPE]="subvolume"
VALIDITY[PARENT,TYPE,,TYPE]="subvolume"
VALIDITY[PEER,TYPE,DRIVE,TYPE]="drive"
VALIDITY[PEER,TYPE,PARTITION,TYPE]="partition"
VALIDITY[PEER,TYPE,SWAP,TYPE]=""

INFER[TYPE,SUBVOLUME,PARENT,FSTYPE]="btrfs"
INFER[TYPE,PARTITION,PARENT,TYPE]="drive"

OPTIONS[REQUIRED,TYPE,DRIVE]=""
OPTIONS[REQUIRED,TYPE,PARTITION]="size"
OPTIONS[REQUIRED,TYPE,ENCRYPTION]="label"
OPTIONS[REQUIRED,TYPE,FILESYSTEM]="fstype mountpoint"
OPTIONS[REQUIRED,TYPE,SUBVOLUME]="mountpoint"
OPTIONS[REQUIRED,TYPE,SWAP]=""

CLASS[RULETYPE,FILTER]
    
OPTIONS[VALID,TYPE,DRIVE]="bootable noclobber ssd devpath"
OPTIONS[VALID,TYPE,PARTITION]="bootable noclobber ssd devpath label code size"
OPTIONS[VALID,TYPE,FILESYSTEM]="bootable noclobber ssd devpath label fstype"
REFERENCE

# vim: set filetype=sh :
