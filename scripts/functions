:<< \
-----------------------------------------------------------------------
HELPER FUNCTIONS
-----------------------------------------------------------------------

# pacman/aur

AUR_INSTALL () {
	PKG=$1; CURDIR="$(pwd)"
	TMPDIR=/tmp; [ -d $TMPDIR ] || mkdir $TMPDIR; cd $TMPDIR
        [ -z ${UPDATED:-} ] && pacman --noconfirm -Sy && typeset -g UPDATED=true
	rm -rf ${PKG}* || true
	curl -O https://aur.archlinux.org/packages/${PKG:0:2}/${PKG}/${PKG}.tar.gz
	tar -xzvf ${PKG}.tar.gz
	cd ${PKG}
	makepkg --noconfirm --syncdeps --clean --needed --install
	cd $TMPDIR
	rm -rf ${PKG}* || true
	cd "$CURDIR"
	}

INSTALL () {
    if ! which pacaur; then
        sudo pacman -Sy
        AUR_INSTALL cower
        AUR_INSTALL pacaur
    fi
    [ -n $@ ] && pacaur --noconfirm --noedit -S $@;
}

# System

detectMemory () {
    print "$(( $(print ${$(cat /proc/meminfo | grep -i memtotal)[2]}) / 1000000 ))G"
}

# General

notifySection () { print "\n\n$@\n\n"; }
notify () { print "\n$@\n"; }

conformToArray () {
# takes a global variable NAME as an argument, ensures that it is an
# array, not a simple list (doesn't damage existing arrays)
eval "$1=($(print ${(P)1}))"
}

enableServices () {
for servicename in $@; do
    systemctl enable $servicename
done
}

removeFromArray() { eval $1=\("\${(@)$1:#$2}"\); }

addToCommaList () {
    varname=$1
    typeset -g $varname
    varcontent="${(P)1}"
    shift
    for newvalue in $@; do
        varcontent="${varcontent%,}${varcontent:+,}${newvalue#,}"
    done
    typeset -g $varname="${varcontent%,}"
}

# Passphrase

setPassphrase() {
        returnvar=$1
        typeset -g $returnvar
	typeset passphrase="" confirmation=""
        prompt="${2:-passphrase}"
	while [[ -z "$passphrase" ]]; do
	    print -n " Enter $prompt   : "
	    read -rs passphrase
            print
	    print -n " Confirm $prompt : "
	    read -rs confirmation
            print
	    #print; read -rs "passphrase?Enter $prompt : "
	    #echo "\n\n"; read -rs "confirmation?Confirm $prompt    : "
	    #echo "\n\n"
	    if [[ "$passphrase" != "$confirmation" ]]; then
		print "\nInput does not match!"
		passphrase="" confirmation=""
	    fi
	done
	#print -rn "$passphrase"
        typeset -g $returnvar="$passphrase"
	unset passphrase confirmation
}

# Block Device Related

deviceHasMountpoint() { [[ -n "$(/usr/bin/lsblk -dno MOUNTPOINT $1)" ]]; }

deviceOrChildHasMountpoint() { [[ -n "$(/usr/bin/lsblk -no MOUNTPOINT $1)" ]] && return 0 || mount | grep $1; }

setCurrentBlockItem () {
    local itemnumber=$1
    ITEMVALUES=($COLNAMES PATH PARTNUM MOUNTED_BTRFS_SUBVOL)
    for VALUENAME in $ITEMVALUES; do
        [[ -z ${BLOCKITEM[$itemnumber,$VALUENAME]:-} ]] \
	|| typeset -g _$VALUENAME="${BLOCKITEM[$itemnumber,$VALUENAME]}"
    done
    if [[ -n ${_CHILD_OF:-} ]]; then
        local parentitemnumber=${BLOCKITEM_NUM_FROM_LABEL[$_CHILD_OF]:-}
        for VALUENAME in $ITEMVALUES; do
            [[ -z ${BLOCKITEM[$parentitemnumber,$VALUENAME]:-} ]] \
	    || typeset -g _PARENT_$VALUENAME="${BLOCKITEM[$parentitemnumber,$VALUENAME]}"
        done
    fi
}

unsetCurrentBlockItem () {
    ITEMVALUES=($COLNAMES PATH PARTNUM MOUNTED_BTRFS_SUBVOL)
    for VALUENAME in $ITEMVALUES; do
        unset _$VALUENAME
        unset _PARENT_$VALUENAME
    done
}

setCurrentRecordFromTable () {
    _record_index=$1
    _record_field_names_ref=$2
    _table_values_ref=$3
    _record_fields=($_record_field_names PATH PARTITION_NUM MOUNTED_BTRFS_SUBVOL)
    for _field_name in $_record_fields; do
        [[ -z ${(P)_table_values_ref[$_record_index,$_field_name]:-} ]] \
	|| typeset -g _$_field_name="${(P)_table_values_ref[$_record_index,$_field_name]}"
    done
    if [[ -n ${_CHILD_OF:-} ]]; then
        #local _parent_item_number=${BLOCKITEM_NUM_FROM_LABEL[$_CHILD_OF]:-}
        local _parent_item_number=${(P)_table_values_ref[xxx$_CHILD_OF]:-}
        for VALUENAME in $ITEMVALUES; do
            [[ -z ${BLOCKITEM[$parentitemnumber,$VALUENAME]:-} ]] \
	    || typeset -g _PARENT_$VALUENAME="${BLOCKITEM[$parentitemnumber,$VALUENAME]}"
        done
    fi
}

getParentFilesystemTypeFromLabel () {
    this_label=$1
    this_item_num=$BLOCKITEM_NUM_FROM_LABEL[$this_label]
    parent_label="${BLOCKITEM[$this_item_num,CHILD_OF]:-}"
    if [[ -n $parent_label ]]; then
        parent_item_num=$BLOCKITEM_NUM_FROM_LABEL[$parent_label]
        parent_item_fs="${BLOCKITEM[$parent_item_num,FSTYPE]}"
        print -n $parent_item_fs
    else
        return 1
    fi
}

checkForLuksAncestor () {
    this_label=$1
    this_item_num=$BLOCKITEM_NUM_FROM_LABEL[$this_label]
    parent_fs=$(getParentFilesystemTypeFromLabel $this_label)
    if [[ $parent_fs == luks ]]; then
        return 0
    elif [[ -n ${BLOCKITEM[$this_item_num,CHILD_OF]:-} ]]; then
        checkForLuksAncestor ${BLOCKITEM[$this_item_num,CHILD_OF]}
    else
        return 1
    fi
}

selectInstallTarget () {
assignToVarname=$1

# Create list of drives
# Remove mounted drives from list
drives=($(/usr/bin/lsblk --paths --nodeps --noheadings --output NAME))
print "FULL LIST OF DRIVES:"
print -l "$drives"
print
for drive in $drives; do deviceOrChildHasMountpoint $drive && removeFromArray drives $drive || :; done
print "----------"
print "LIST OF DRIVES WITH NO MOUNT:"
print -l "$drives"

# User selects drive for install
CONFIRM="" SELECTED=""
while [[ ! $CONFIRM =~ [Yy] ]]; do

        # List drives
        echo "\n\n\nAvailable unmounted drives for installation:"
        echo "--------------------------------------------"
	for drive in $drives; do print "[$(( i += 1))] $drive ($(/usr/bin/lsblk -dno SIZE $drive))"; done

        # Pick drive or quit
	echo -n "\nPlease enter the number of the drive you wish to install to, or 'q' to quit: (1$((($i > 1)) && echo "-$i")/q) "
	while [[ -z $SELECTED || ! $SELECTED =~ [1-$i] && ! ${(L)SELECTED} == "q" ]]; do print -n "\b \b"; read -k 1 SELECTED || :; done # read returns an error code at EOF, so we ignore it
        if [[ $SELECTED == "q" ]]; then echo; exit; fi

        # Identify as SSD or standard
	echo -n "\nIs $drives[$SELECTED] an SSD? (y/N):"
        read -k SSD || :; [[ ${(L)SSD} == y ]] && SSD="" || unset SSD; echo

        # Summarize and confirm
	echo -n "\n\nYou have selected $drives[$SELECTED] for COMPLETE ERASURE, and identified it as ${SSD-NOT }an SSD. Enter'y' to continue or 'n' to make changes or 'q' to quit: (y/N/q) "
        read -k CONFIRM ||:; echo
        [[ ${(L)CONFIRM} == "q" ]] && exit || :

done

eval "$assignToVarname=$drives[$SELECTED]"
}


extractFieldNames () { typeset -ga $2; eval $2'=($(print ${(P)1[2]};))'; }
extractFieldValues () { typeset -ga $2; eval $2'=($(print ${(P)1[3,-2]};))'; }
calculateNumberOfRecords () {
_num_field_values=${(P)#1}
_num_field_names=${(P)#2}
_num_records=$(( ${_num_field_values} / ${_num_field_names} ))
if (( ${_num_field_values} != (${_num_field_names} * $_num_records) )); then
    return 1
else
    typeset -g $3
    eval $3'=$_num_records'
    return 0
fi
}

parseTableToRecords () {

_field_values_ref=$1; typeset -ag $_field_values_ref
_field_names_ref=$2;  typeset -ag $_field_names_ref
_num_records_ref=$3;  typeset -g $_num_records_ref
_result_array_ref=$4; typeset -Ag $_result_array_ref

calculateNumberOfRecords $_field_values_ref $_field_names_ref $_num_records_ref || return 1

# assign to local arrays due to error resulting from taking
# a count of a dereferenced varaible e.g. ${(P)#_reference} was
# failing, though uncertain why as it works in other tests and
# test scripts....
_field_names=(${(P)_field_names_ref})
_field_values=(${(P)_field_values_ref})
_iteration=0
for _record_index in {1..${(P)_num_records_ref}}; do
    for _field_index in {1..${#_field_names}}; do
        _field_value="${_field_values[$((${#_field_names} * $_iteration + $_field_index))]}"
        if [[ ! "$_field_value" =~ [_-] ]]; then
            eval $_result_array_ref'[${_record_index},${_field_names[$_field_index]}]="$_field_values[$((${#_field_names} * $_iteration + $_field_index))]"'
#create reverse lookup
#should be able to use subscript flags to do this instead
            # set record index from fieldname... this will only be used/useful
            # in cases of unique values like labels and mountpoints, for example
            eval $_result_array_ref'[RECORD_INDEX_FROM_FIELDNAME,${_field_names[$_field_index]},${_field_value}]=${_record_index}'
        fi
    done
    _iteration=$(( $_iteration + 1 ))
done
}

dumpArray () {
# functionally equivalent to 'typeset arrayname',
# but more readable for testing
    for arrayname
    do
        for key in ${(@kP)arrayname}
        do    
            eval 'print "$arrayname\[$key\]=${'$arrayname'[$key]:-}"'
        done
    done
}

:<< \
'NOTES--------------------------------'

list all associative array keys that start with "prefix":
print ${arrayname[(I)prefix*]}

list the values of the same results:
print ${(v)arrayname[(I)prefix*]}

search values in array for a pattern and return the key name:
print ${(k)arrayname[(r)searchpattern]}


NOTES--------------------------------
